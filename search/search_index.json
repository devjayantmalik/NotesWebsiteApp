{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Jayant Learning Center : Here excellence develops, we learn to develop and design world. Note : we want you to use multiple IDE for learning, this verifies your code portability. Programming in C : Pre requirement : No prior programming knowledge is required. It will be helpful if you have programmed before in any language but it is optional Contents : Lecture Name Description Intro to programming Basics terms such as software, programs, technology etc. History of C History behind development of c and first hello world program. Printing on Screen Comments, Using printf to get output on screen Variables Datatypes and variables More on variables variables in more depth Operators unary, binary, ternary operators, postfix unary, prefix unary, arithmetic, relational, logical, bitwise More on Operators short circuit behaviour of and, or, rule of associativity, rule of precedence Arrays short circuit behaviour of and, or, precedence, associativity Control statements types of control structures, if..else, switch...case, ternary More on Control Statements loop control structure, while, for, do..while Functions Types of function, evaluation order, arguments Pointers pointer types, pointer arithmetic More on Functions call by value, call by reference, nested function declaration, recursive functions Preprocessor Directives header files, macros, types of preprocessor More on Preprocessor conditional preprocessors. Built in functions prototype of functions related to string, number, character, error, buffer and memory Reference Guide a quick reference guide for useful functions in c Functions With Pointers functions returning pointers as return type Built in Functions of char type Formation of built in char related functions, generating dll, using dll with programs. Structures in C why structures?, where to use them?, syntax of structure, value access inside structure, direct and indirect component selector, memory formation, typedef with structure, pointers with structure. File Handling file operations, FILE buffer, file handling functions, usage with example for each function Interesting-Facts-About-C body of c program without braces, keep buffer open till a specific letter is typed.","title":"Home"},{"location":"#welcome-to-jayant-learning-center","text":"Here excellence develops, we learn to develop and design world.","title":"Welcome to Jayant Learning Center :"},{"location":"#note","text":"we want you to use multiple IDE for learning, this verifies your code portability.","title":"Note :"},{"location":"#programming-in-c","text":"","title":"Programming in C :"},{"location":"#pre-requirement","text":"No prior programming knowledge is required. It will be helpful if you have programmed before in any language but it is optional","title":"Pre requirement :"},{"location":"#contents","text":"Lecture Name Description Intro to programming Basics terms such as software, programs, technology etc. History of C History behind development of c and first hello world program. Printing on Screen Comments, Using printf to get output on screen Variables Datatypes and variables More on variables variables in more depth Operators unary, binary, ternary operators, postfix unary, prefix unary, arithmetic, relational, logical, bitwise More on Operators short circuit behaviour of and, or, rule of associativity, rule of precedence Arrays short circuit behaviour of and, or, precedence, associativity Control statements types of control structures, if..else, switch...case, ternary More on Control Statements loop control structure, while, for, do..while Functions Types of function, evaluation order, arguments Pointers pointer types, pointer arithmetic More on Functions call by value, call by reference, nested function declaration, recursive functions Preprocessor Directives header files, macros, types of preprocessor More on Preprocessor conditional preprocessors. Built in functions prototype of functions related to string, number, character, error, buffer and memory Reference Guide a quick reference guide for useful functions in c Functions With Pointers functions returning pointers as return type Built in Functions of char type Formation of built in char related functions, generating dll, using dll with programs. Structures in C why structures?, where to use them?, syntax of structure, value access inside structure, direct and indirect component selector, memory formation, typedef with structure, pointers with structure. File Handling file operations, FILE buffer, file handling functions, usage with example for each function Interesting-Facts-About-C body of c program without braces, keep buffer open till a specific letter is typed.","title":"Contents :"},{"location":"about/","text":"About Jayant's Academy Dear user, to keep the content updated and our service alive, we work really hard. If you want to support us, please contribute to our project. We will be more than happy to see you in our team. The project is currently maintained by one individual Jayant Malik The content is fully provided for free. If you want to support us, please donate at: Gateway Address Paypal demo@paypal.com Paytm demo@paytm.com UPI mobile@upi PhonePe username@phonepe Contact details: In any case you need my help, feel free to contact me via: Source Details Email devjayantmalik@gmail.com Mobile Sorry, i don't have any mobile phone. Github github.com/devjayantmalik I will try my best to help you out. I am not employeed or hired so, i cannot guarantee you that this project will always remain alive. This project depends, on people like you. Thanks for your contribution. Thanks and Love to you all Firstly, I want to thank all my team mates, who made this project possible. The great inspiration and co-ordination of my team mates encouraged me to burn midnight oil. The success always brings a feeling of joy, and the failures always teach the path to success. The same happened while working on this project. The journey was quite enlightning. The content was generated from experience. The definitions or any piece of text used in this project is not copied from any book or article. The complete project is based on practical approach and is written as per my experience. I believe that failures are most important in our life, because they provide us an opportunity to shine. While, reading the content, you will experience such mile stones. The path taken by us to write and teach the content is the hard way, because we want you to experiment as much as possible. After combining your efforts with our efforts, you will definitely achieve a goal that will, make you stand on top of this world. Now, I want to thank of some most respected personalities for me. These personalites permitted me with their blessings and support. My parents and my teachers, who encouraged me to contribute in this world. My friends and my team mates, who provided me an opportunity to learn new skills and teach them to the world. All my viewers, students and you, who is currently supporting the project.","title":"About"},{"location":"about/#about-jayants-academy","text":"Dear user, to keep the content updated and our service alive, we work really hard. If you want to support us, please contribute to our project. We will be more than happy to see you in our team. The project is currently maintained by one individual Jayant Malik The content is fully provided for free. If you want to support us, please donate at: Gateway Address Paypal demo@paypal.com Paytm demo@paytm.com UPI mobile@upi PhonePe username@phonepe","title":"About Jayant's Academy"},{"location":"about/#contact-details","text":"In any case you need my help, feel free to contact me via: Source Details Email devjayantmalik@gmail.com Mobile Sorry, i don't have any mobile phone. Github github.com/devjayantmalik I will try my best to help you out. I am not employeed or hired so, i cannot guarantee you that this project will always remain alive. This project depends, on people like you. Thanks for your contribution.","title":"Contact details:"},{"location":"about/#thanks-and-love-to-you-all","text":"Firstly, I want to thank all my team mates, who made this project possible. The great inspiration and co-ordination of my team mates encouraged me to burn midnight oil. The success always brings a feeling of joy, and the failures always teach the path to success. The same happened while working on this project. The journey was quite enlightning. The content was generated from experience. The definitions or any piece of text used in this project is not copied from any book or article. The complete project is based on practical approach and is written as per my experience. I believe that failures are most important in our life, because they provide us an opportunity to shine. While, reading the content, you will experience such mile stones. The path taken by us to write and teach the content is the hard way, because we want you to experiment as much as possible. After combining your efforts with our efforts, you will definitely achieve a goal that will, make you stand on top of this world. Now, I want to thank of some most respected personalities for me. These personalites permitted me with their blessings and support. My parents and my teachers, who encouraged me to contribute in this world. My friends and my team mates, who provided me an opportunity to learn new skills and teach them to the world. All my viewers, students and you, who is currently supporting the project.","title":"Thanks and Love to you all"},{"location":"c/01-intro/","text":"Programming: art of solving problems using a language that computer could understand is called as programming. Software: A set of programs is called as software. Program: A set of instructions is called as program. Avoid duplicate code. Why we need Programming? We need programming to create new softwares. to update existing softwares. Translator: software engineer ---- translator ----- machine code translator is a piece of software that translates programming language code to machine code. Types of translator: Interpreter Compiler Interpreter: Interpreter Compiler Reads --- check syntax --- translates --- execute (Works per line) Reads whole file ---- check syntax --- translates ---generates output file. Do not store machine code in file Stores machine code in a file Executes code after translation. Do not execute code after translation. Conclusion : Languages that are based on interpreter are called as interpreter based language. Languages that are based on compiler are called as compiler based languages. Examples of Compiler based language : C, C++, Java, C#, ....etc. Examples of interpreter based language : HTML, JavaScript, PHP .... etc. Compiler is less secure as compared to interpreter. because code is translated only once and after that it is executed again and again without re-translation. Adding of virus or code to compiler generated .exe file is easy.","title":"01. Introduction"},{"location":"c/01-intro/#programming","text":"art of solving problems using a language that computer could understand is called as programming.","title":"Programming:"},{"location":"c/01-intro/#software","text":"A set of programs is called as software.","title":"Software:"},{"location":"c/01-intro/#program","text":"A set of instructions is called as program. Avoid duplicate code.","title":"Program:"},{"location":"c/01-intro/#why-we-need-programming","text":"We need programming to create new softwares. to update existing softwares.","title":"Why we need Programming?"},{"location":"c/01-intro/#translator","text":"software engineer ---- translator ----- machine code translator is a piece of software that translates programming language code to machine code.","title":"Translator:"},{"location":"c/01-intro/#types-of-translator","text":"Interpreter Compiler","title":"Types of translator:"},{"location":"c/01-intro/#interpreter","text":"Interpreter Compiler Reads --- check syntax --- translates --- execute (Works per line) Reads whole file ---- check syntax --- translates ---generates output file. Do not store machine code in file Stores machine code in a file Executes code after translation. Do not execute code after translation.","title":"Interpreter:"},{"location":"c/01-intro/#conclusion","text":"Languages that are based on interpreter are called as interpreter based language. Languages that are based on compiler are called as compiler based languages. Examples of Compiler based language : C, C++, Java, C#, ....etc. Examples of interpreter based language : HTML, JavaScript, PHP .... etc. Compiler is less secure as compared to interpreter. because code is translated only once and after that it is executed again and again without re-translation. Adding of virus or code to compiler generated .exe file is easy.","title":"Conclusion :"},{"location":"c/02-history-and-first-program/","text":"Software Engineer : A person who has knowledge of programming is a software engineer. sometimes also called as software scientist. Software Scientist > Software Vendor > Software user > Software end user. Software Scientist (Software creator) : creates software or technology. Software Vendor: distribute technology on behalf of software creator. Software User: Uses technology to create bulk products Software End user: uses technology product created Technology: Creation of some product or project is technology. 1. Tech Creator created a technology.( Thomas created technology to make bulbs) 2. Vendor distributed that technology.. (Let's say xyz) 3. User used that technology to create in bulk (Philips company workers) 4. End user used that product (We light our homes with bulb) History of C : Unix was first Developed by Ken Thompson in posix. The language was not able to fix all issues in linux. Now Ken Thompson needed a language to rewrite linux. Writing a new language will take a lot of time so, He took help of his junior Dennis R. Ritche. Ken Thompson told Dennis what he wanted to do with Language and Dennis wrote all functionalities what Ken wanted. Now Language was written and it was ready to used. Ken Thompson rewrote the entire OS in C. After 2 years he released Unix (Portable and multi-tasking) The Problem was that linux was 16 bit. So, it was slow. We needed some OS that works fast. Richard was 12 years old student who learnt C and was from New Zealand. He told people that OS could work on 32 bit. People did not believe him. He wrote one linux command in 32 bit and proved that it could be written in 32 bit. Richard gathered people who were familiar with C and asked each of them to write one command in 32 bit so, Linux become OS of community and was written in C. What is 16 bit? The one cycle of Processor to work is called tic. If any OS completes 16 bit of Work in one cycle then it is called 16 bit. Summary : Unix was created by Ken Thompson. Dennis Ritche created C language. Unix was 16 bit Linux was 32 bit written by community and started by Richard. Let's Discuss about C Inclusion of 'stdio.h' in not necessary. Follow ANSI Standard. Case sensitive language. Most of built in functions are in small case. Requirements to run C program on machine. Text Editor Compiler API (Application Programming Interface) Debugger Manual Who will provide me all these things? Tech Creator or Tech Vendor. Software could be categorised in two parts : Software Projects Software Products Software Projects: Software Projects are made for specific purpose and are available to specific person even after completion of software by developer. Example - Metro Ticketing System. It could be only by metro employees. You can take tickets but cannot use software to issue tickets. Software Products: Software Products are, those software which are made for general purpose, and are available to a wide range of persons. Example- Microsoft Word, Paint, Tally, VLC, AllPlayer, etc... These software could be used by anyone for their own purposes. Before Completion After Completion Called As Project Project Project Project Product Product C Program ```c #include int main() { printf(\"Hello World\\n\"); return 0; } ``` C Program Explanation: Header files Contain pre-built functions prototypes and macros for us. These are included using a reserved keyword #include main is entry point of our C program. Every program should have a main function. In our case main returns an integer value. return is a reserved keyword in C to return a value back from function. printf is a function used to print some output to screen. Statement Terminator ';' or semicolon is used to terminate c Statement.","title":"02. History and First Program"},{"location":"c/02-history-and-first-program/#software-engineer","text":"A person who has knowledge of programming is a software engineer. sometimes also called as software scientist. Software Scientist > Software Vendor > Software user > Software end user. Software Scientist (Software creator) : creates software or technology. Software Vendor: distribute technology on behalf of software creator. Software User: Uses technology to create bulk products Software End user: uses technology product created","title":"Software Engineer :"},{"location":"c/02-history-and-first-program/#technology","text":"Creation of some product or project is technology. 1. Tech Creator created a technology.( Thomas created technology to make bulbs) 2. Vendor distributed that technology.. (Let's say xyz) 3. User used that technology to create in bulk (Philips company workers) 4. End user used that product (We light our homes with bulb)","title":"Technology:"},{"location":"c/02-history-and-first-program/#history-of-c","text":"Unix was first Developed by Ken Thompson in posix. The language was not able to fix all issues in linux. Now Ken Thompson needed a language to rewrite linux. Writing a new language will take a lot of time so, He took help of his junior Dennis R. Ritche. Ken Thompson told Dennis what he wanted to do with Language and Dennis wrote all functionalities what Ken wanted. Now Language was written and it was ready to used. Ken Thompson rewrote the entire OS in C. After 2 years he released Unix (Portable and multi-tasking) The Problem was that linux was 16 bit. So, it was slow. We needed some OS that works fast. Richard was 12 years old student who learnt C and was from New Zealand. He told people that OS could work on 32 bit. People did not believe him. He wrote one linux command in 32 bit and proved that it could be written in 32 bit. Richard gathered people who were familiar with C and asked each of them to write one command in 32 bit so, Linux become OS of community and was written in C.","title":"History of C :"},{"location":"c/02-history-and-first-program/#what-is-16-bit","text":"The one cycle of Processor to work is called tic. If any OS completes 16 bit of Work in one cycle then it is called 16 bit.","title":"What is 16 bit?"},{"location":"c/02-history-and-first-program/#summary","text":"Unix was created by Ken Thompson. Dennis Ritche created C language. Unix was 16 bit Linux was 32 bit written by community and started by Richard.","title":"Summary :"},{"location":"c/02-history-and-first-program/#lets-discuss-about-c","text":"Inclusion of 'stdio.h' in not necessary. Follow ANSI Standard. Case sensitive language. Most of built in functions are in small case.","title":"Let's Discuss about C"},{"location":"c/02-history-and-first-program/#requirements-to-run-c-program-on-machine","text":"Text Editor Compiler API (Application Programming Interface) Debugger Manual","title":"Requirements to run C program on machine."},{"location":"c/02-history-and-first-program/#who-will-provide-me-all-these-things","text":"Tech Creator or Tech Vendor.","title":"Who will provide me all these things?"},{"location":"c/02-history-and-first-program/#software-could-be-categorised-in-two-parts","text":"Software Projects Software Products","title":"Software could be categorised in two parts :"},{"location":"c/02-history-and-first-program/#software-projects","text":"Software Projects are made for specific purpose and are available to specific person even after completion of software by developer. Example - Metro Ticketing System. It could be only by metro employees. You can take tickets but cannot use software to issue tickets.","title":"Software Projects:"},{"location":"c/02-history-and-first-program/#software-products","text":"Software Products are, those software which are made for general purpose, and are available to a wide range of persons. Example- Microsoft Word, Paint, Tally, VLC, AllPlayer, etc... These software could be used by anyone for their own purposes. Before Completion After Completion Called As Project Project Project Project Product Product","title":"Software Products:"},{"location":"c/02-history-and-first-program/#c-program","text":"```c #include int main() { printf(\"Hello World\\n\"); return 0; } ```","title":"C Program"},{"location":"c/02-history-and-first-program/#c-program-explanation","text":"Header files Contain pre-built functions prototypes and macros for us. These are included using a reserved keyword #include main is entry point of our C program. Every program should have a main function. In our case main returns an integer value. return is a reserved keyword in C to return a value back from function. printf is a function used to print some output to screen. Statement Terminator ';' or semicolon is used to terminate c Statement.","title":"C Program Explanation:"},{"location":"c/03-printing-on-screen/","text":"Comments : Comments are used to document our code, they help other programmers what our code is all about. Comments are not translated by compiler, they are deleted at time of compilation from output file. Source file will still contain comments, note that they are deleted from .exe or .out file Single Line Comments : Single line comments are started using double forward slashes and they are automatically terminated at end of line, means for termination you do not use any operator. Syntax : int main() { // This is a single line comment. return 0; } Multi-line Comments : Multi-line comments are used to document code that spans multiple lines. Nesting is not allowed in multi-line comments, that a comment cannot contain another comment within it, this happens only in case of multi-line comment. They starts with a forward slash and an asterisk symbol. They end using asterisk symbol followed by a forward slash. Syntax : int main() { /* Hello This is a multiline comment. */ // Most commonly used as : /* * First line * Second line */ return 0; } Why do we need to plan a c program? We program in C because we want computer to do some task for us. How do we program in C? In order to program in c we have following instructions : Input Instructions (scanf) Output Instructions (printf) Conditional Instructions (while, if, for, loops) Declarative Instructions (variables, pointers) Input Instructions : These instructions are required to take input from keyboard within our program. Output instructions : These instructions are required to print output to standard output device, that is monitor. Conditional Instructions : These instructions are used to write repetition code and code that evaluates on conditions. Declarative Instructions : These instructions are used to reserve some memory in OS for our input. Note : One tab equals 8 spaces. Structure of C program : header files global variables main function declaration { body of program. } Example of C program : #include<stdio.h> //header file int main() { //main function declaration printf(\"Hello World\"); //print output on screen return 0; //returns value back from function. } Addition in printf : More than one string passed passed to printf without commas will combine together to form a single string. int main() { printf(\"Hello\" \"Jayant\" \"Malik\"); return 0; } Escape Sequences in printf : Escape sequences are used to shift cursor position at specific location. //escape sequences are used with backslash followed by specific letters. int main() { printf(\"Hello Jayant 1\\n\"); // prints a new line at end of text. printf(\"Hello Jayant 2\\r\"); // carriage return printf(\"Hello Jayant 3\\b\"); // backspace printf(\"Hello Jayant 4\\t\"); // tab return 0; } Note : Use manual of ANSI C for more escape sequence characters. Example of new line : int main() { int a=0; // local variable while(a<=10) { // while loop a++; // a = a+1 printf(\"This is line no : %d\\n\", a); } } Example of carriage return int main() { int x = 0; // in borland compiler use delay(milli_second) function // to understand it better or use a higher value of x in loop. while(x<=100){ x++; printf(\"%d\\r\",x); } return 0; } Example of Backspace Escape Sequence Character : int main() { printf(\"Hello\\b\\b\\b\"); // shift cursor three position back. printf(\"AB\"); return 0; } Let's See Borland Compiler Specific Code int main() { textcolor(10); // sets text color textbackground(4) // sets textbackground color\\ cprintf(\"Hello in Color\"); // only works in borland delay(2000); //sets delay in milliseconds gotoxy(30,13); // changes cursor position (col, row) } Let's Clear the Screen clrscr is a function used to clear the screen in DOS only. Think it as compiler specific code. int main() { printf(\"India is great.\"); clrscr(); }","title":"03. Printing"},{"location":"c/03-printing-on-screen/#comments","text":"Comments are used to document our code, they help other programmers what our code is all about. Comments are not translated by compiler, they are deleted at time of compilation from output file. Source file will still contain comments, note that they are deleted from .exe or .out file","title":"Comments :"},{"location":"c/03-printing-on-screen/#single-line-comments","text":"Single line comments are started using double forward slashes and they are automatically terminated at end of line, means for termination you do not use any operator. Syntax : int main() { // This is a single line comment. return 0; }","title":"Single Line Comments :"},{"location":"c/03-printing-on-screen/#multi-line-comments","text":"Multi-line comments are used to document code that spans multiple lines. Nesting is not allowed in multi-line comments, that a comment cannot contain another comment within it, this happens only in case of multi-line comment. They starts with a forward slash and an asterisk symbol. They end using asterisk symbol followed by a forward slash. Syntax : int main() { /* Hello This is a multiline comment. */ // Most commonly used as : /* * First line * Second line */ return 0; }","title":"Multi-line Comments :"},{"location":"c/03-printing-on-screen/#why-do-we-need-to-plan-a-c-program","text":"We program in C because we want computer to do some task for us.","title":"Why do we need to plan a c program?"},{"location":"c/03-printing-on-screen/#how-do-we-program-in-c","text":"In order to program in c we have following instructions : Input Instructions (scanf) Output Instructions (printf) Conditional Instructions (while, if, for, loops) Declarative Instructions (variables, pointers)","title":"How do we program in C?"},{"location":"c/03-printing-on-screen/#input-instructions","text":"These instructions are required to take input from keyboard within our program.","title":"Input Instructions :"},{"location":"c/03-printing-on-screen/#output-instructions","text":"These instructions are required to print output to standard output device, that is monitor.","title":"Output instructions :"},{"location":"c/03-printing-on-screen/#conditional-instructions","text":"These instructions are used to write repetition code and code that evaluates on conditions.","title":"Conditional Instructions :"},{"location":"c/03-printing-on-screen/#declarative-instructions","text":"These instructions are used to reserve some memory in OS for our input. Note : One tab equals 8 spaces.","title":"Declarative Instructions :"},{"location":"c/03-printing-on-screen/#structure-of-c-program","text":"header files global variables main function declaration { body of program. }","title":"Structure of C program :"},{"location":"c/03-printing-on-screen/#example-of-c-program","text":"#include<stdio.h> //header file int main() { //main function declaration printf(\"Hello World\"); //print output on screen return 0; //returns value back from function. }","title":"Example of C program :"},{"location":"c/03-printing-on-screen/#addition-in-printf","text":"More than one string passed passed to printf without commas will combine together to form a single string. int main() { printf(\"Hello\" \"Jayant\" \"Malik\"); return 0; }","title":"Addition in printf :"},{"location":"c/03-printing-on-screen/#escape-sequences-in-printf","text":"Escape sequences are used to shift cursor position at specific location. //escape sequences are used with backslash followed by specific letters. int main() { printf(\"Hello Jayant 1\\n\"); // prints a new line at end of text. printf(\"Hello Jayant 2\\r\"); // carriage return printf(\"Hello Jayant 3\\b\"); // backspace printf(\"Hello Jayant 4\\t\"); // tab return 0; } Note : Use manual of ANSI C for more escape sequence characters.","title":"Escape Sequences in printf :"},{"location":"c/03-printing-on-screen/#example-of-new-line","text":"int main() { int a=0; // local variable while(a<=10) { // while loop a++; // a = a+1 printf(\"This is line no : %d\\n\", a); } }","title":"Example of new line :"},{"location":"c/03-printing-on-screen/#example-of-carriage-return","text":"int main() { int x = 0; // in borland compiler use delay(milli_second) function // to understand it better or use a higher value of x in loop. while(x<=100){ x++; printf(\"%d\\r\",x); } return 0; }","title":"Example of carriage return"},{"location":"c/03-printing-on-screen/#example-of-backspace-escape-sequence-character","text":"int main() { printf(\"Hello\\b\\b\\b\"); // shift cursor three position back. printf(\"AB\"); return 0; }","title":"Example of Backspace Escape Sequence Character :"},{"location":"c/03-printing-on-screen/#lets-see-borland-compiler-specific-code","text":"int main() { textcolor(10); // sets text color textbackground(4) // sets textbackground color\\ cprintf(\"Hello in Color\"); // only works in borland delay(2000); //sets delay in milliseconds gotoxy(30,13); // changes cursor position (col, row) }","title":"Let's See Borland Compiler Specific Code"},{"location":"c/03-printing-on-screen/#lets-clear-the-screen","text":"clrscr is a function used to clear the screen in DOS only. Think it as compiler specific code. int main() { printf(\"India is great.\"); clrscr(); }","title":"Let's Clear the Screen"},{"location":"c/04-variables/","text":"Variables : Variables are place holders in RAM, which provides us ability to store data. Rules for Variables : Variable Names could contain letters, digits and underscore character. Variable name should start with a letter or underscore variable name should not contain spaces. Variable name length should be atleast one character. Variable name should not contain any special character except underscore. Note: In case of GCC compiler $ symbol is allowed. Types of Variables : Global Variable / Public Variables Local Variable / Private Variables Syntax of declaring variable : datatype variable_name; datatype variable_name = value; Examples of variables : int marks = 10; int age; // age declared without any value. age =10; // age assigned a value. Local Variables : The variables which are present within a function are called as local variables. Examples of Local Variables : int main() { //local scope variables int age = 10; char grade = 'A'; float pi = 3.14f; return 0; } Examples of Global Variables : float PI = 3.14; int main(){ printf(\"Value of PI is %f\",PI); return 0; } Scopes of Variables : Public Scope - means any part of program is able to use them. Private Scope - means only specific part of Program is able to use them. You Tell me... Which type of variable according to you has public scope? Which type of variable according to you has private scope? Basic Conventions For Global Variables : Conventions are optional, They are rules followed by most of developers around the world. You may choose to implement them in your programs to keep seperate of concerns. Name your variable in UPPER CASE Declare your variables with pre allocated value.(to prevent garbage value) In case you do not know what value the variable will hold then, provide a suitable value to prevent garbage value. Keep length of characters in variable name to be minimum. Variable name should not exceed 50 characters. Variable name should be descriptive. Basic Conventions for Local Variables : Name you variable in CAMEL CASE. Declare your variable with default value to prevent allocation of garbage value. Variable name should be descriptive. On program execution : OS will create account of Program in STACK. OS will allocate some space in RAM. OS will generate address of allocation unit. OS will store address of variable in STACK. STACK Exists in RAM itself somewhere. Stack : Stack is a space in RAM created by OS to keep account of program and its variables. Stack helps OS keep record of RAM bits used by saveral programs during concurrent operations. Makes Multitasking possible. How Program Execution Works : $$$ Program asks ---> OS allocate me some memory OS Creates Account of Program ---> OS Allocates Space in RAM OS Stores Address of Memory in STACK Program Asks OS to store value in variable OS fetches Address of variable from stack. OS fetches data of variable stored at that address OS provides program data in binary form Program converts data as required $$$ Why were local variables developed ? Let's see source code of some program to understand this, int Multiply(int first, int second){ return first * second; } int Sum(int a, int b){ return a + b; } int main(){ printf(\"a = %d and b = %d\",a,b); return 0; } In above situation, Our program has 3 functions. But None of Sum and Multiply functions are used in program. Our Sum() function has two local variables a and b. Our main function prints values of a and b on execution. We notice that, in our situation all three variables are local. Let's Execute the program and see what happens : Result : We got an error that a and b are not defined. It means a and b variables are not allocated any space in RAM by OS. So, Local variables prevent unnecessary space allocation in RAM. and this is the reason, why local variables were created. Why were global variables developed ? Let's again see source code of some program to understand this, float PI =3.14; float AreaOfCircle(float radius){ return PI * (radius * radius); } int main(){ printf(\"Value of PI is %f\",PI); float area = AreaOfCircle(23.4f); printf(\"Area of Circle is %f\",area); } In above situation : * We have a global variable PI. * We have two functions that uses value of PI. In above situation we notice that PI is a global variable. Conclusion : So global variables to created to avoid duplicate variable declaration. This makes OS Fast and Efficient. Conclusions of why variables were created : Prevents duplicate code. Makes system faster. Prevents unnecessary usage of RAM. Reduces overall software size.","title":"04. Variables"},{"location":"c/04-variables/#variables","text":"Variables are place holders in RAM, which provides us ability to store data.","title":"Variables :"},{"location":"c/04-variables/#rules-for-variables","text":"Variable Names could contain letters, digits and underscore character. Variable name should start with a letter or underscore variable name should not contain spaces. Variable name length should be atleast one character. Variable name should not contain any special character except underscore. Note: In case of GCC compiler $ symbol is allowed.","title":"Rules for Variables :"},{"location":"c/04-variables/#types-of-variables","text":"Global Variable / Public Variables Local Variable / Private Variables","title":"Types of Variables :"},{"location":"c/04-variables/#syntax-of-declaring-variable","text":"datatype variable_name; datatype variable_name = value;","title":"Syntax of declaring variable :"},{"location":"c/04-variables/#examples-of-variables","text":"int marks = 10; int age; // age declared without any value. age =10; // age assigned a value.","title":"Examples of variables :"},{"location":"c/04-variables/#local-variables","text":"The variables which are present within a function are called as local variables.","title":"Local Variables :"},{"location":"c/04-variables/#examples-of-local-variables","text":"int main() { //local scope variables int age = 10; char grade = 'A'; float pi = 3.14f; return 0; }","title":"Examples of Local Variables :"},{"location":"c/04-variables/#examples-of-global-variables","text":"float PI = 3.14; int main(){ printf(\"Value of PI is %f\",PI); return 0; }","title":"Examples of Global Variables :"},{"location":"c/04-variables/#scopes-of-variables","text":"Public Scope - means any part of program is able to use them. Private Scope - means only specific part of Program is able to use them.","title":"Scopes of Variables :"},{"location":"c/04-variables/#you-tell-me","text":"Which type of variable according to you has public scope? Which type of variable according to you has private scope?","title":"You Tell me..."},{"location":"c/04-variables/#basic-conventions-for-global-variables","text":"Conventions are optional, They are rules followed by most of developers around the world. You may choose to implement them in your programs to keep seperate of concerns. Name your variable in UPPER CASE Declare your variables with pre allocated value.(to prevent garbage value) In case you do not know what value the variable will hold then, provide a suitable value to prevent garbage value. Keep length of characters in variable name to be minimum. Variable name should not exceed 50 characters. Variable name should be descriptive.","title":"Basic Conventions For Global Variables :"},{"location":"c/04-variables/#basic-conventions-for-local-variables","text":"Name you variable in CAMEL CASE. Declare your variable with default value to prevent allocation of garbage value. Variable name should be descriptive.","title":"Basic Conventions for Local Variables :"},{"location":"c/04-variables/#on-program-execution","text":"OS will create account of Program in STACK. OS will allocate some space in RAM. OS will generate address of allocation unit. OS will store address of variable in STACK. STACK Exists in RAM itself somewhere.","title":"On program execution :"},{"location":"c/04-variables/#stack","text":"Stack is a space in RAM created by OS to keep account of program and its variables. Stack helps OS keep record of RAM bits used by saveral programs during concurrent operations. Makes Multitasking possible.","title":"Stack :"},{"location":"c/04-variables/#how-program-execution-works","text":"","title":"How Program Execution Works :"},{"location":"c/04-variables/#_1","text":"","title":"$$$"},{"location":"c/04-variables/#program-asks-os-allocate-me-some-memory","text":"","title":"Program asks ---&gt; OS allocate me some memory"},{"location":"c/04-variables/#os-creates-account-of-program-os-allocates-space-in-ram","text":"","title":"OS Creates Account of Program ---&gt; OS Allocates Space in RAM"},{"location":"c/04-variables/#os-stores-address-of-memory-in-stack","text":"","title":"OS Stores Address of Memory in STACK"},{"location":"c/04-variables/#program-asks-os-to-store-value-in-variable","text":"","title":"Program Asks OS to store value in variable"},{"location":"c/04-variables/#os-fetches-address-of-variable-from-stack","text":"","title":"OS fetches Address of variable from stack."},{"location":"c/04-variables/#os-fetches-data-of-variable-stored-at-that-address","text":"","title":"OS fetches data of variable stored at that address"},{"location":"c/04-variables/#os-provides-program-data-in-binary-form","text":"","title":"OS provides program data in binary form"},{"location":"c/04-variables/#program-converts-data-as-required","text":"","title":"Program converts data as required"},{"location":"c/04-variables/#_2","text":"","title":"$$$"},{"location":"c/04-variables/#why-were-local-variables-developed","text":"Let's see source code of some program to understand this, int Multiply(int first, int second){ return first * second; } int Sum(int a, int b){ return a + b; } int main(){ printf(\"a = %d and b = %d\",a,b); return 0; } In above situation, Our program has 3 functions. But None of Sum and Multiply functions are used in program. Our Sum() function has two local variables a and b. Our main function prints values of a and b on execution. We notice that, in our situation all three variables are local. Let's Execute the program and see what happens : Result : We got an error that a and b are not defined. It means a and b variables are not allocated any space in RAM by OS. So, Local variables prevent unnecessary space allocation in RAM. and this is the reason, why local variables were created.","title":"Why were local variables developed ?"},{"location":"c/04-variables/#why-were-global-variables-developed","text":"Let's again see source code of some program to understand this, float PI =3.14; float AreaOfCircle(float radius){ return PI * (radius * radius); } int main(){ printf(\"Value of PI is %f\",PI); float area = AreaOfCircle(23.4f); printf(\"Area of Circle is %f\",area); } In above situation : * We have a global variable PI. * We have two functions that uses value of PI. In above situation we notice that PI is a global variable.","title":"Why were global variables developed ?"},{"location":"c/04-variables/#conclusion","text":"So global variables to created to avoid duplicate variable declaration. This makes OS Fast and Efficient.","title":"Conclusion :"},{"location":"c/04-variables/#conclusions-of-why-variables-were-created","text":"Prevents duplicate code. Makes system faster. Prevents unnecessary usage of RAM. Reduces overall software size.","title":"Conclusions of why variables were created :"},{"location":"c/05-more-on-variables/","text":"How much memory does variable reserve ? It depends on datatype of variable and Architecture of OS, few datatypes as per 16 bit OS are : int - 2 bytes char - 1 byte float - 4 bytes double - 8 bytes Using sizeof() function : C provides us some predefined datatypes, such as int, float, char, double etc. These datatypes reserves different memory in RAM as per datatype. sizeof() function return int as return value in bytes. sizeof() function takes datatype as its argument. sizeof() function also takes variable_name as its argument. sizeof() function also takes direct value as its argument. Example of sizeof() function : int main(){ int age = 18; // size using variable. printf(\"int has size of %d bytes\", sizeof(age)); // size using datatype printf(\"float has size of %d bytes\", sizeof(float)); // size using value printf(\"char has size of %d bytes\", sizeof('A')); return 0; } Datatypes in C: unsigned int signed int unsigned char signed char unsigned float signed float and few more.......... Note : unsigned allows only positive values. signed allows positive as well as negative values. Memory Allocation for signed datatype : let's assume the memory in form of blocks that are represented by square brackets [] . so, memory becomes, char = 1 byte = 8 bits = [1][][][][][][][] In case of signed datatypes : First most bit is reserved for signature info. This first most bit is called as sign bit. Sign bit holds two values : 0 for positive values. and 1 for negative values. Points to Remember : OS stores data in RAM in form of bits 0 or 1. Bits are states of current experienced by hardware. Memory or RAM is divided in bits. Calculation of Size and range of values : Representation of memory in case of char: [][][][][][][][] Minimum binaries that 8 bits could hold is : 00000000 Maximum binaries that 8 bits could hold is : 11111111 Let's check binary : 1 | 00000001 2 | 00000010 .... .... 255 | 11111111 Here, we notice that when number is converted in binary 255 is the maximum value that results in 11111111 which is equivalent to maximum storage reserved in RAM. How will i convert a number to Binary ? 255 /2 | 1 127 /2 | 1 063 /2 | 1 031 /2 | 1 015 /2 | 1 007 /2 | 1 003 /2 | 1 001 /2 | 1 Steps are : Take any number that you want to convert. (255 in our example) Divide the number by 2 and note its remainder and quotient as seen above. Again divide the quotient by 2 until we get zero as quotient. As a remainder we obtain binary of the number. Conclusion : we learnt how to convert integer number to binary. now you can convert binary to number and find maximum range of variable. Cyclic behaviour : Cyclic behaviour is used to determine value of variable that will be provided as result when user enters beyond variable's maximum range. Example signed char could hold values from -128 to 127. What happens when user enters 128 Program shows cyclic behaviour. //figure of cyclic behaviour (0) ---------- (127) ' ' ' ' ' ' (-1) --------- (-128) So, as per the figure the result obtained will be -128 The above concept of cyclic behaviour applies to all datatypes in c.","title":"05. More on Variables"},{"location":"c/05-more-on-variables/#how-much-memory-does-variable-reserve","text":"It depends on datatype of variable and Architecture of OS, few datatypes as per 16 bit OS are : int - 2 bytes char - 1 byte float - 4 bytes double - 8 bytes","title":"How much memory does variable reserve ?"},{"location":"c/05-more-on-variables/#using-sizeof-function","text":"C provides us some predefined datatypes, such as int, float, char, double etc. These datatypes reserves different memory in RAM as per datatype. sizeof() function return int as return value in bytes. sizeof() function takes datatype as its argument. sizeof() function also takes variable_name as its argument. sizeof() function also takes direct value as its argument.","title":"Using sizeof() function :"},{"location":"c/05-more-on-variables/#example-of-sizeof-function","text":"int main(){ int age = 18; // size using variable. printf(\"int has size of %d bytes\", sizeof(age)); // size using datatype printf(\"float has size of %d bytes\", sizeof(float)); // size using value printf(\"char has size of %d bytes\", sizeof('A')); return 0; }","title":"Example of sizeof() function :"},{"location":"c/05-more-on-variables/#datatypes-in-c","text":"unsigned int signed int unsigned char signed char unsigned float signed float and few more..........","title":"Datatypes in C:"},{"location":"c/05-more-on-variables/#note","text":"unsigned allows only positive values. signed allows positive as well as negative values.","title":"Note :"},{"location":"c/05-more-on-variables/#memory-allocation-for-signed-datatype","text":"let's assume the memory in form of blocks that are represented by square brackets [] . so, memory becomes, char = 1 byte = 8 bits = [1][][][][][][][]","title":"Memory Allocation for signed datatype :"},{"location":"c/05-more-on-variables/#in-case-of-signed-datatypes","text":"First most bit is reserved for signature info. This first most bit is called as sign bit. Sign bit holds two values : 0 for positive values. and 1 for negative values.","title":"In case of signed datatypes :"},{"location":"c/05-more-on-variables/#points-to-remember","text":"OS stores data in RAM in form of bits 0 or 1. Bits are states of current experienced by hardware. Memory or RAM is divided in bits.","title":"Points to Remember :"},{"location":"c/05-more-on-variables/#calculation-of-size-and-range-of-values","text":"","title":"Calculation of Size and range of values :"},{"location":"c/05-more-on-variables/#representation-of-memory-in-case-of-char","text":"[][][][][][][][] Minimum binaries that 8 bits could hold is : 00000000 Maximum binaries that 8 bits could hold is : 11111111","title":"Representation of memory in case of char:"},{"location":"c/05-more-on-variables/#lets-check-binary","text":"1 | 00000001 2 | 00000010 .... .... 255 | 11111111 Here, we notice that when number is converted in binary 255 is the maximum value that results in 11111111 which is equivalent to maximum storage reserved in RAM.","title":"Let's check binary :"},{"location":"c/05-more-on-variables/#how-will-i-convert-a-number-to-binary","text":"255 /2 | 1 127 /2 | 1 063 /2 | 1 031 /2 | 1 015 /2 | 1 007 /2 | 1 003 /2 | 1 001 /2 | 1 Steps are : Take any number that you want to convert. (255 in our example) Divide the number by 2 and note its remainder and quotient as seen above. Again divide the quotient by 2 until we get zero as quotient. As a remainder we obtain binary of the number.","title":"How will i convert a number to Binary ?"},{"location":"c/05-more-on-variables/#conclusion","text":"we learnt how to convert integer number to binary. now you can convert binary to number and find maximum range of variable.","title":"Conclusion :"},{"location":"c/05-more-on-variables/#cyclic-behaviour","text":"Cyclic behaviour is used to determine value of variable that will be provided as result when user enters beyond variable's maximum range. Example signed char could hold values from -128 to 127. What happens when user enters 128 Program shows cyclic behaviour. //figure of cyclic behaviour (0) ---------- (127) ' ' ' ' ' ' (-1) --------- (-128) So, as per the figure the result obtained will be -128","title":"Cyclic behaviour :"},{"location":"c/05-more-on-variables/#the-above-concept-of-cyclic-behaviour-applies-to-all-datatypes-in-c","text":"","title":"The above concept of cyclic behaviour applies to all datatypes in c."},{"location":"c/06-operators/","text":"Definition Special kind of symbols that are part of ASCII characters and have specific meaning in programming language are called as operators. +, -, /, * are examples of operators. Types of operators based on inputs: Unary Operators Binary Operators Terniary Operator Unary Operators The operators that takes single input are called as unary operators. Example : ! not operator. int main() { int status = 1; if(!status){ // converts status value to zero. // body will not execute in this case. } } Binary Operators The operators that takes two inputs are called as binary operators. Example: result = 20 + 30; '+' plus operator takes two input. '-' minus operator takes two input. int main() { int age = 10; // assignment operator. int sum = age + 10; // plus operator float salary = 10 * 90; // multiplication operator double length = 200 / 10; // divide operator. /* Some short operators*/ length += 2; // equivalent to length = length + 2; length++; // equivalent to length = length + 1; age--; sum -= 2; salary *= 0.20f; salary /= 2; return 0; } Terniary Operator The operator that takes three inputs are called as terniary operators. They are mainly used in place of if else. Syntax : (expression_returning_zero_or_one) ? true_case : false_case; Example : int result = (10 > 20) ? 1 : 0; ?: is a terniary operator int fact() { // code to find factorial. } int main() { int number = 0; printf(\"Enter a number to calculate factorial:\\t\"); scanf(\"%d\",&number); int result = (number != 0) ? fact(number) : 1; printf(\"%d factorial is %d:\\n\", number, result); return 0; } Post-fix and prefix unary operators : Post-fix unary : These operators are mainly placed after a variable. number++; In case of post-fix, there is formation of temporary memory location and in this temporary location the original value of operator is stored. Working of post-fix : int main() { int marks = 65; printf(\"postfix : %d\\n\",marks++); // result is 65. return 0; } Create a temporary memory location to store original value present in variable. Increments the original value. Returns value stored at temporary memory location created in step 1. Prefix unary operator : These operators are placed before a variable. ++number; In case of prefix unary operator, original variable is incremented or decremented, there is no formation of temporary memory. Working of prefix : int main(){ int number = 100; printf(\"prefix: %d\\n\",++number); // result is 101 return 0; } Increment the original value. Returns the incremented value. Types of operators : Arithmetic Operators. Relational Operators. Logical operators Bitwise Operators. Arithmetic Operators : The operators used to perform simple mathematical arithmetic. '+', '-', '*', '/', '%' int main() { int number1 = 0; int number2 = 0; printf(\"Enter first number :\\t\"); scanf(\"%d\",&number1); printf(\"Enter first number :\\t\"); scanf(\"%d\",&number2); int addition = number1 + number2; int subtraction = number1 + number2; long int multiplication = number 1 * number2; float division = number1 / number2; int remainder = number1 % number2; printf(\"Addition : %d\\n\", addition); printf(\"Subtraction : %d\\n\", subtraction); printf(\"Multiplication : %ld\\n\", multiplication); printf(\"Division : %f\\n\", division); printf(\"Remainder : %d\\n\", remainder); return 0; } Relational Operators : The operators that used to check relations between two values. '>', '<', '>=', '<=', '==', '!=' int main() { int num1 = 10; int num2 = 20; printf(\"Greater than : %d\\n\", num1 > num2); printf(\"Less than : %d\\n\", num1 < num2); printf(\"Greater or Equal : %d\\n\", num1 >= num2); printf(\"Less or Equal : %d\\n\", num1 <= num2); printf(\"Equals to : %d\\n\", num1 == num2); printf(\"Not Equals : %d\\n\", num1 != num2); return 0; } Logical Operators : These operators are used to check for logical conditions, such as : and or. '&&' and operator '||' or operator int main() { int age = 0; printf(\"Enter your age:\\t\"); scanf(\"%d\",&age); if(age > 18 && age < 50){ printf(\"You are eligible for voting.\\n\"); } if(age < 18 || age > 50){ printf(\"You are not eligible for voting.\\n\"); } return 0; } Evaluation of logical operators : The logical operators are evaluated based on physics gate table. Logical And : Condition 1 Condition 2 Result 1 1 1 1 0 0 0 1 0 0 0 0 Logical Or : Condition 1 Condition 2 Result 1 1 1 1 0 1 0 1 1 0 0 0 Bitwise Operators : These operators works only on binaries, that is zero and one, of their operands. The value on which operator operates is called as operand. '>>' left binary shift operator. '<<' right binary shift operator. '|' bitwise or operator. '&' bitwise and operator. '^' bitwise exclusive or '~' bitwise exclusive not. Example : int main() { printf(\"%d\\n\", 3 << 5); return 0; } Bitwise OR Denoted by a '|' (pipe) symbol. Working of Bitwise OR : takes two number as input. Converts both numbers to binary. Compares each digit of binary, if any of digit is found to be 1 result is 1. Table of output : First Input Second Input Output 0 0 0 0 1 0 1 0 1 1 1 1 Example of Bitwise OR : // bitwise or void or() { int result = 1 | 5; /* * 128 64 32 16 8 4 2 1 * 0 0 0 0 0 0 0 1 Equals 1. * 0 0 0 0 0 1 0 1 Equals 5 * ============================= * 0 0 0 0 0 1 0 1 Equals 5 */ printf(\"1 | 5 = %d\\n\", result); result = 15 | 8; /* * 128 64 32 16 8 4 2 1 * 0 0 0 0 1 1 1 1 Equals 15 * 0 0 0 0 1 0 0 0 Equals 8 * =============================== * 0 0 0 0 1 1 1 1 Equals 15 */ printf(\"15 | 8 = %d\\n\", result); } int main(){ or(); return 0; } Bitwise And Denoted by a '&' (and / address of) symbol. Working of Bitwise And : takes two number as input. Converts both numbers to binary. Compares each digit of binary, if any of digit is found to be 0 result is 0. Table of output : First Input Second Input Output 0 0 0 0 1 0 1 0 0 1 1 1 Example of Bitwise And : // Bitwise and void and() { int result = 2 & 5; /* * 128 64 32 16 8 4 2 1 Places. * 0 0 0 0 0 0 1 0 Equals 2 * 0 0 0 0 0 1 0 1 Equals 5 * ============================== * 0 0 0 0 0 0 0 0 Equals zero. */ printf(\"2 & 5 is %d\\n\", result); result = 1 & 5; /* * 128 64 32 16 8 4 2 1 Places * 0 0 0 0 0 0 0 1 Equals 1 * 0 0 0 0 0 1 0 1 Equals 5 * =============================== * 0 0 0 0 0 0 0 1 Equals 1 */ printf(\"1 & 5 Equals : %d\\n\", result); } int main() { and(); return 0; } Bitwise XOR Denoted by a '^' (power) symbol. Working of Bitwise XOR : takes two number as input. Converts both numbers to binary. Compares each digit of binary, if both digit of first and second numbers are different, result is 1 else 0 Table of output : First Input Second Input Output 0 0 0 0 1 1 1 0 1 1 1 0 Example of Bitwise xor : // Bitwise exclusive or void xor() { /* * xor gives 1 only where, * first binary is different, * from second binary at same place. */ int result = 2 ^ 5; /* * 128 64 32 16 8 4 2 1 Places * 0 0 0 0 0 0 1 0 Equals 2 * 0 0 0 0 0 1 0 1 Equals 5 * ================================ * 0 0 0 0 0 1 1 1 Equals 7 */ printf(\"2 ^ 5 = %d\\n\", result); result = 13 ^ 16; /* * 128 64 32 16 8 4 2 1 Places * 0 0 0 0 1 1 0 1 Equals 13 * 0 0 0 1 0 0 0 0 Equals 16 * ================================= * 0 0 0 1 1 1 0 1 Equals 29 */ printf(\"13 ^ 16 = %d\\n\", result); } int main() { xor(); return 0; } Bitwise NOT Denoted by a '~' (tilde) symbol. Working of Bitwise NOT : takes one number as input. Converts the number to binary. Reverses the bits of the number Again, bits are reversed except sign bit. Now, one is added to the number. Example of Bitwise NOT : // bitwise not void not() { int result = ~5; /* * 128 64 32 16 8 4 2 1 Places * 0 0 0 0 0 1 0 1 Equals 5 * ============================ * 1 1 1 1 1 0 1 0 Equals 250 // bits reversed * 1 0 0 0 0 1 0 1 Equals -5 // again reversed except sign bit * 1 0 0 0 0 1 1 1 Equals -6 // 1 is added to number. */ printf(\"~5 = %d\\n\", result); result = ~14; /* * 128 64 32 16 8 4 2 1 Places * 0 0 0 0 1 1 1 0 Equals 14 * 1 1 1 1 0 0 0 1 Equals 241 * 1 0 0 0 1 1 1 0 Equals -14 * 1 0 0 0 1 1 1 1 Equals -15 */ printf(\"~14 = %d\\n\", result); } int main() { not(); return 0; } Bitwise left shift Denoted by a '>>' (left stream operator) operator. Works only on positive values. left side denotes the number right side denotes the no. of bits to shift. Working of Bitwise left shift : takes two numbers as input. Converts the number to binary. Shifts the numbers binary towards left, by number of bits provided as second input. Example of left shift : void leftshift() { unsigned int result = 4 << 1; /* * 128 64 32 16 8 4 2 1 Places * 0 0 0 0 0 1 0 0 Equals 4 * ============================== * 0 0 0 0 1 0 0 0 Equals 8 */ printf(\"4 << 1 = %d\\n\", result); result = 15 << 4; /* * 128 64 32 16 8 4 2 1 Places * 0 0 0 0 1 1 1 1 Equals 15 * ============================ * 1 1 1 1 0 0 0 0 Equals 240 */ printf(\"15 << 4 = %d\\n\", result); } int main() { leftshift(); return 0; } Bitwise right shift : Denoted by a '<<' (less than less than) operator. Works only on positive values. left side denotes the no. of bits to shift. right side denotes the number Working of Bitwise right shift : takes two numbers as input. Converts the number to binary. Shifts the numbers binary towards right, by number of bits provided as first input. Example of right shift : void rightshift() { int result = 4 >> 1; /* * 128 64 32 16 8 4 2 1 * 0 0 0 0 0 1 0 0 Equals 4 * ============================== * 0 0 0 0 0 0 1 0 Equals 2 */ printf(\"4 >> 1 = %d\\n\", result); result = 15 >> 4; /* * 128 64 32 16 8 4 2 1 * 0 0 0 0 1 1 1 1 Equals 15 * ============================ * 0 0 0 0 0 0 0 0 Equals 0 */ printf(\"15 >> 4 = %d\\n\", result); } int main() { rightshift(); return 0; }","title":"06. Operators"},{"location":"c/06-operators/#definition","text":"Special kind of symbols that are part of ASCII characters and have specific meaning in programming language are called as operators. +, -, /, * are examples of operators.","title":"Definition"},{"location":"c/06-operators/#types-of-operators-based-on-inputs","text":"Unary Operators Binary Operators Terniary Operator","title":"Types of operators based on inputs:"},{"location":"c/06-operators/#unary-operators","text":"The operators that takes single input are called as unary operators. Example : ! not operator. int main() { int status = 1; if(!status){ // converts status value to zero. // body will not execute in this case. } }","title":"Unary Operators"},{"location":"c/06-operators/#binary-operators","text":"The operators that takes two inputs are called as binary operators. Example: result = 20 + 30; '+' plus operator takes two input. '-' minus operator takes two input. int main() { int age = 10; // assignment operator. int sum = age + 10; // plus operator float salary = 10 * 90; // multiplication operator double length = 200 / 10; // divide operator. /* Some short operators*/ length += 2; // equivalent to length = length + 2; length++; // equivalent to length = length + 1; age--; sum -= 2; salary *= 0.20f; salary /= 2; return 0; }","title":"Binary Operators"},{"location":"c/06-operators/#terniary-operator","text":"The operator that takes three inputs are called as terniary operators. They are mainly used in place of if else. Syntax : (expression_returning_zero_or_one) ? true_case : false_case; Example : int result = (10 > 20) ? 1 : 0; ?: is a terniary operator int fact() { // code to find factorial. } int main() { int number = 0; printf(\"Enter a number to calculate factorial:\\t\"); scanf(\"%d\",&number); int result = (number != 0) ? fact(number) : 1; printf(\"%d factorial is %d:\\n\", number, result); return 0; }","title":"Terniary Operator"},{"location":"c/06-operators/#post-fix-and-prefix-unary-operators","text":"","title":"Post-fix and prefix unary operators :"},{"location":"c/06-operators/#post-fix-unary","text":"These operators are mainly placed after a variable. number++; In case of post-fix, there is formation of temporary memory location and in this temporary location the original value of operator is stored.","title":"Post-fix unary :"},{"location":"c/06-operators/#working-of-post-fix","text":"int main() { int marks = 65; printf(\"postfix : %d\\n\",marks++); // result is 65. return 0; } Create a temporary memory location to store original value present in variable. Increments the original value. Returns value stored at temporary memory location created in step 1.","title":"Working of post-fix :"},{"location":"c/06-operators/#prefix-unary-operator","text":"These operators are placed before a variable. ++number; In case of prefix unary operator, original variable is incremented or decremented, there is no formation of temporary memory.","title":"Prefix unary operator :"},{"location":"c/06-operators/#working-of-prefix","text":"int main(){ int number = 100; printf(\"prefix: %d\\n\",++number); // result is 101 return 0; } Increment the original value. Returns the incremented value.","title":"Working of prefix :"},{"location":"c/06-operators/#types-of-operators","text":"Arithmetic Operators. Relational Operators. Logical operators Bitwise Operators.","title":"Types of operators :"},{"location":"c/06-operators/#arithmetic-operators","text":"The operators used to perform simple mathematical arithmetic. '+', '-', '*', '/', '%' int main() { int number1 = 0; int number2 = 0; printf(\"Enter first number :\\t\"); scanf(\"%d\",&number1); printf(\"Enter first number :\\t\"); scanf(\"%d\",&number2); int addition = number1 + number2; int subtraction = number1 + number2; long int multiplication = number 1 * number2; float division = number1 / number2; int remainder = number1 % number2; printf(\"Addition : %d\\n\", addition); printf(\"Subtraction : %d\\n\", subtraction); printf(\"Multiplication : %ld\\n\", multiplication); printf(\"Division : %f\\n\", division); printf(\"Remainder : %d\\n\", remainder); return 0; }","title":"Arithmetic Operators :"},{"location":"c/06-operators/#relational-operators","text":"The operators that used to check relations between two values. '>', '<', '>=', '<=', '==', '!=' int main() { int num1 = 10; int num2 = 20; printf(\"Greater than : %d\\n\", num1 > num2); printf(\"Less than : %d\\n\", num1 < num2); printf(\"Greater or Equal : %d\\n\", num1 >= num2); printf(\"Less or Equal : %d\\n\", num1 <= num2); printf(\"Equals to : %d\\n\", num1 == num2); printf(\"Not Equals : %d\\n\", num1 != num2); return 0; }","title":"Relational Operators :"},{"location":"c/06-operators/#logical-operators","text":"These operators are used to check for logical conditions, such as : and or. '&&' and operator '||' or operator int main() { int age = 0; printf(\"Enter your age:\\t\"); scanf(\"%d\",&age); if(age > 18 && age < 50){ printf(\"You are eligible for voting.\\n\"); } if(age < 18 || age > 50){ printf(\"You are not eligible for voting.\\n\"); } return 0; }","title":"Logical Operators :"},{"location":"c/06-operators/#evaluation-of-logical-operators","text":"The logical operators are evaluated based on physics gate table.","title":"Evaluation of logical operators :"},{"location":"c/06-operators/#logical-and","text":"Condition 1 Condition 2 Result 1 1 1 1 0 0 0 1 0 0 0 0","title":"Logical And :"},{"location":"c/06-operators/#logical-or","text":"Condition 1 Condition 2 Result 1 1 1 1 0 1 0 1 1 0 0 0","title":"Logical Or :"},{"location":"c/06-operators/#bitwise-operators","text":"These operators works only on binaries, that is zero and one, of their operands. The value on which operator operates is called as operand. '>>' left binary shift operator. '<<' right binary shift operator. '|' bitwise or operator. '&' bitwise and operator. '^' bitwise exclusive or '~' bitwise exclusive not. Example : int main() { printf(\"%d\\n\", 3 << 5); return 0; }","title":"Bitwise Operators :"},{"location":"c/06-operators/#bitwise-or","text":"Denoted by a '|' (pipe) symbol.","title":"Bitwise OR"},{"location":"c/06-operators/#working-of-bitwise-or","text":"takes two number as input. Converts both numbers to binary. Compares each digit of binary, if any of digit is found to be 1 result is 1.","title":"Working of Bitwise OR :"},{"location":"c/06-operators/#table-of-output","text":"First Input Second Input Output 0 0 0 0 1 0 1 0 1 1 1 1","title":"Table of output :"},{"location":"c/06-operators/#example-of-bitwise-or","text":"// bitwise or void or() { int result = 1 | 5; /* * 128 64 32 16 8 4 2 1 * 0 0 0 0 0 0 0 1 Equals 1. * 0 0 0 0 0 1 0 1 Equals 5 * ============================= * 0 0 0 0 0 1 0 1 Equals 5 */ printf(\"1 | 5 = %d\\n\", result); result = 15 | 8; /* * 128 64 32 16 8 4 2 1 * 0 0 0 0 1 1 1 1 Equals 15 * 0 0 0 0 1 0 0 0 Equals 8 * =============================== * 0 0 0 0 1 1 1 1 Equals 15 */ printf(\"15 | 8 = %d\\n\", result); } int main(){ or(); return 0; }","title":"Example of Bitwise OR :"},{"location":"c/06-operators/#bitwise-and","text":"Denoted by a '&' (and / address of) symbol.","title":"Bitwise And"},{"location":"c/06-operators/#working-of-bitwise-and","text":"takes two number as input. Converts both numbers to binary. Compares each digit of binary, if any of digit is found to be 0 result is 0.","title":"Working of Bitwise And :"},{"location":"c/06-operators/#table-of-output_1","text":"First Input Second Input Output 0 0 0 0 1 0 1 0 0 1 1 1","title":"Table of output :"},{"location":"c/06-operators/#example-of-bitwise-and","text":"// Bitwise and void and() { int result = 2 & 5; /* * 128 64 32 16 8 4 2 1 Places. * 0 0 0 0 0 0 1 0 Equals 2 * 0 0 0 0 0 1 0 1 Equals 5 * ============================== * 0 0 0 0 0 0 0 0 Equals zero. */ printf(\"2 & 5 is %d\\n\", result); result = 1 & 5; /* * 128 64 32 16 8 4 2 1 Places * 0 0 0 0 0 0 0 1 Equals 1 * 0 0 0 0 0 1 0 1 Equals 5 * =============================== * 0 0 0 0 0 0 0 1 Equals 1 */ printf(\"1 & 5 Equals : %d\\n\", result); } int main() { and(); return 0; }","title":"Example of Bitwise And :"},{"location":"c/06-operators/#bitwise-xor","text":"Denoted by a '^' (power) symbol.","title":"Bitwise XOR"},{"location":"c/06-operators/#working-of-bitwise-xor","text":"takes two number as input. Converts both numbers to binary. Compares each digit of binary, if both digit of first and second numbers are different, result is 1 else 0","title":"Working of Bitwise XOR :"},{"location":"c/06-operators/#table-of-output_2","text":"First Input Second Input Output 0 0 0 0 1 1 1 0 1 1 1 0","title":"Table of output :"},{"location":"c/06-operators/#example-of-bitwise-xor","text":"// Bitwise exclusive or void xor() { /* * xor gives 1 only where, * first binary is different, * from second binary at same place. */ int result = 2 ^ 5; /* * 128 64 32 16 8 4 2 1 Places * 0 0 0 0 0 0 1 0 Equals 2 * 0 0 0 0 0 1 0 1 Equals 5 * ================================ * 0 0 0 0 0 1 1 1 Equals 7 */ printf(\"2 ^ 5 = %d\\n\", result); result = 13 ^ 16; /* * 128 64 32 16 8 4 2 1 Places * 0 0 0 0 1 1 0 1 Equals 13 * 0 0 0 1 0 0 0 0 Equals 16 * ================================= * 0 0 0 1 1 1 0 1 Equals 29 */ printf(\"13 ^ 16 = %d\\n\", result); } int main() { xor(); return 0; }","title":"Example of Bitwise xor :"},{"location":"c/06-operators/#bitwise-not","text":"Denoted by a '~' (tilde) symbol.","title":"Bitwise NOT"},{"location":"c/06-operators/#working-of-bitwise-not","text":"takes one number as input. Converts the number to binary. Reverses the bits of the number Again, bits are reversed except sign bit. Now, one is added to the number.","title":"Working of Bitwise NOT :"},{"location":"c/06-operators/#example-of-bitwise-not","text":"// bitwise not void not() { int result = ~5; /* * 128 64 32 16 8 4 2 1 Places * 0 0 0 0 0 1 0 1 Equals 5 * ============================ * 1 1 1 1 1 0 1 0 Equals 250 // bits reversed * 1 0 0 0 0 1 0 1 Equals -5 // again reversed except sign bit * 1 0 0 0 0 1 1 1 Equals -6 // 1 is added to number. */ printf(\"~5 = %d\\n\", result); result = ~14; /* * 128 64 32 16 8 4 2 1 Places * 0 0 0 0 1 1 1 0 Equals 14 * 1 1 1 1 0 0 0 1 Equals 241 * 1 0 0 0 1 1 1 0 Equals -14 * 1 0 0 0 1 1 1 1 Equals -15 */ printf(\"~14 = %d\\n\", result); } int main() { not(); return 0; }","title":"Example of Bitwise NOT :"},{"location":"c/06-operators/#bitwise-left-shift","text":"Denoted by a '>>' (left stream operator) operator. Works only on positive values. left side denotes the number right side denotes the no. of bits to shift.","title":"Bitwise left shift"},{"location":"c/06-operators/#working-of-bitwise-left-shift","text":"takes two numbers as input. Converts the number to binary. Shifts the numbers binary towards left, by number of bits provided as second input.","title":"Working of Bitwise left shift :"},{"location":"c/06-operators/#example-of-left-shift","text":"void leftshift() { unsigned int result = 4 << 1; /* * 128 64 32 16 8 4 2 1 Places * 0 0 0 0 0 1 0 0 Equals 4 * ============================== * 0 0 0 0 1 0 0 0 Equals 8 */ printf(\"4 << 1 = %d\\n\", result); result = 15 << 4; /* * 128 64 32 16 8 4 2 1 Places * 0 0 0 0 1 1 1 1 Equals 15 * ============================ * 1 1 1 1 0 0 0 0 Equals 240 */ printf(\"15 << 4 = %d\\n\", result); } int main() { leftshift(); return 0; }","title":"Example of left shift :"},{"location":"c/06-operators/#bitwise-right-shift","text":"Denoted by a '<<' (less than less than) operator. Works only on positive values. left side denotes the no. of bits to shift. right side denotes the number","title":"Bitwise right shift :"},{"location":"c/06-operators/#working-of-bitwise-right-shift","text":"takes two numbers as input. Converts the number to binary. Shifts the numbers binary towards right, by number of bits provided as first input.","title":"Working of Bitwise right shift :"},{"location":"c/06-operators/#example-of-right-shift","text":"void rightshift() { int result = 4 >> 1; /* * 128 64 32 16 8 4 2 1 * 0 0 0 0 0 1 0 0 Equals 4 * ============================== * 0 0 0 0 0 0 1 0 Equals 2 */ printf(\"4 >> 1 = %d\\n\", result); result = 15 >> 4; /* * 128 64 32 16 8 4 2 1 * 0 0 0 0 1 1 1 1 Equals 15 * ============================ * 0 0 0 0 0 0 0 0 Equals 0 */ printf(\"15 >> 4 = %d\\n\", result); } int main() { rightshift(); return 0; }","title":"Example of right shift :"},{"location":"c/07-more-on-operators/","text":"Some facts : printf() returns number of characters printed on screen. if() could have multiple expressions separated by commas Short Circuit behaviour of && : The and operator will not evaluate other expressions if, any expression, that comes first, is evaluates to zero value. Inside if the expressions are evaluated from left to right. int main() { int num1 = 10; int num2 = 20; // simple usage of if if((num1 != 0) && (num2 != 0)) printf(\"Number one and two are non-zero\\n\"); // Verification of short behaviour // Output : We are inside body of if... if(printf(\"\") && printf(\"Second\")){ printf(\"\\nWe are inside body of if...\\n\"); } return 0; } Short circuit behaviour of || : The or operator will not evaluate expressions futher, if any expression, that comes first, evaluates to non-zero value. int main() { int num1 = 10; int num2 = 20; // simple usage of if if((num1 != 0) || (num2 != 0)) printf(\"Number one and two are non-zero\\n\"); // Verification of short behaviour // Output : First if(printf(\"First\") || printf(\"Second\")){ printf(\"\\nWe are inside body of if...\\n\"); } return 0; } How operators are evaluated ? The operators are evaluated based on precedence table. If you find same operators in a expression then, rule of Associativity is applied. Example : int age = 10 + 20 + 30 + 40; Rule of Precedence and Associativity Rule of precedence, defines the order, in which OS evaluates operators in an expression. There is a precedence table for this task. ANSI has changed precedence table in different versions of C language. Example: int age = 10 + 20 - 30 * 40; Rule of Associativity, defines the direction, in which OS evaluates expression with same operators. Example: int age = 10 + 20 + 30 + 40; Precedence Operator Description Associativity 01 ++, -- Postfix Left to Right 01 () Function Call Left to Right 01 [] Array Subscripting Left to Right 01 . Direct Member Access Left to Right 01 -> Indirect Member Access Left to Right 01 (type){list} Compound Literal Left to Right Precedence Operator Description Associativity 02 ++, -- Postfix Right to left 02 +, - Unary plus minus Right to left 02 !, ~ Logical Not and bitwise not Right to left 02 (type) Unary plus minus Right to left 02 * Unary plus minus Right to left 02 & Unary plus minus Right to left 02 sizeof Unary plus minus Right to left 02 _Alignof Unary plus minus Right to left Precedence Operator Description Associativity 03 *, /, % Multiplication, division, remainder Left to Right Precedence Operator Description Associativity 04 +, - Addition and Subtraction Left to Right Precedence Operator Description Associativity 05 <<, >> Bitwise left shift and right shift Left to Right Precedence Operator Description Associativity 06 <, <= less than and less than equals Left to Right 06 >, >= greater than and greater than equals Left to Right Precedence Operator Description Associativity 07 ==, != Equals and not equals Left to Right Precedence Operator Description Associativity 08 & Bitwise And Left to Right Precedence Operator Description Associativity 09 ^ Bitwise XOR Left to Right Precedence Operator Description Associativity 10 Bitwise OR Precedence Operator Description Associativity 11 && Logical And Left to Right Precedence Operator Description Associativity 12 Precedence Operator Description Associativity 13 ?: Ternary Right to Left Precedence Operator Description Associativity 14 = Assignment Right to Left 14 +=, -= Assignment by sum and difference Right to Left 14 *=, /=, %= Assignment by product quotient remainder Right to Left 14 <<=, >>= Assignment by bitwise left shigt and right shift Right to Left 14 &=, ^=, = Assignment by bitwise AND XOR OR Precedence Operator Description Associativity 15 , Comma Left to Right","title":"07. More on Operators"},{"location":"c/07-more-on-operators/#some-facts","text":"printf() returns number of characters printed on screen. if() could have multiple expressions separated by commas","title":"Some facts :"},{"location":"c/07-more-on-operators/#short-circuit-behaviour-of","text":"The and operator will not evaluate other expressions if, any expression, that comes first, is evaluates to zero value. Inside if the expressions are evaluated from left to right. int main() { int num1 = 10; int num2 = 20; // simple usage of if if((num1 != 0) && (num2 != 0)) printf(\"Number one and two are non-zero\\n\"); // Verification of short behaviour // Output : We are inside body of if... if(printf(\"\") && printf(\"Second\")){ printf(\"\\nWe are inside body of if...\\n\"); } return 0; }","title":"Short Circuit behaviour of &amp;&amp; :"},{"location":"c/07-more-on-operators/#short-circuit-behaviour-of_1","text":"The or operator will not evaluate expressions futher, if any expression, that comes first, evaluates to non-zero value. int main() { int num1 = 10; int num2 = 20; // simple usage of if if((num1 != 0) || (num2 != 0)) printf(\"Number one and two are non-zero\\n\"); // Verification of short behaviour // Output : First if(printf(\"First\") || printf(\"Second\")){ printf(\"\\nWe are inside body of if...\\n\"); } return 0; }","title":"Short circuit behaviour of || :"},{"location":"c/07-more-on-operators/#how-operators-are-evaluated","text":"The operators are evaluated based on precedence table. If you find same operators in a expression then, rule of Associativity is applied. Example : int age = 10 + 20 + 30 + 40;","title":"How operators are evaluated ?"},{"location":"c/07-more-on-operators/#rule-of-precedence-and-associativity","text":"Rule of precedence, defines the order, in which OS evaluates operators in an expression. There is a precedence table for this task. ANSI has changed precedence table in different versions of C language. Example: int age = 10 + 20 - 30 * 40; Rule of Associativity, defines the direction, in which OS evaluates expression with same operators. Example: int age = 10 + 20 + 30 + 40; Precedence Operator Description Associativity 01 ++, -- Postfix Left to Right 01 () Function Call Left to Right 01 [] Array Subscripting Left to Right 01 . Direct Member Access Left to Right 01 -> Indirect Member Access Left to Right 01 (type){list} Compound Literal Left to Right Precedence Operator Description Associativity 02 ++, -- Postfix Right to left 02 +, - Unary plus minus Right to left 02 !, ~ Logical Not and bitwise not Right to left 02 (type) Unary plus minus Right to left 02 * Unary plus minus Right to left 02 & Unary plus minus Right to left 02 sizeof Unary plus minus Right to left 02 _Alignof Unary plus minus Right to left Precedence Operator Description Associativity 03 *, /, % Multiplication, division, remainder Left to Right Precedence Operator Description Associativity 04 +, - Addition and Subtraction Left to Right Precedence Operator Description Associativity 05 <<, >> Bitwise left shift and right shift Left to Right Precedence Operator Description Associativity 06 <, <= less than and less than equals Left to Right 06 >, >= greater than and greater than equals Left to Right Precedence Operator Description Associativity 07 ==, != Equals and not equals Left to Right Precedence Operator Description Associativity 08 & Bitwise And Left to Right Precedence Operator Description Associativity 09 ^ Bitwise XOR Left to Right Precedence Operator Description Associativity 10 Bitwise OR Precedence Operator Description Associativity 11 && Logical And Left to Right Precedence Operator Description Associativity 12 Precedence Operator Description Associativity 13 ?: Ternary Right to Left Precedence Operator Description Associativity 14 = Assignment Right to Left 14 +=, -= Assignment by sum and difference Right to Left 14 *=, /=, %= Assignment by product quotient remainder Right to Left 14 <<=, >>= Assignment by bitwise left shigt and right shift Right to Left 14 &=, ^=, = Assignment by bitwise AND XOR OR Precedence Operator Description Associativity 15 , Comma Left to Right","title":"Rule of Precedence and Associativity"},{"location":"c/08-arrays/","text":"Arrays : Arrays are used to store same kind of data in matrix form. Syntax of array : datatype variable_name[No_of_Matrix][No_of_Rows][No_of_columns]; or datatype variable_name[No_of_Matrix][No_of_Rows][No_of_columns] = {value1, value2, value3}; Example : int main() { // 1-D Array int marks[100] = {1, 2, 3, 4, 5}; int length = sizeof(marks) / sizeof(marks[0]); // printing elements of array. for(int i=0; i<length; i++){ printf(\"%d\\t\",marks[i]); } return 0; } Few important points about arrays : Indexing of array starts with zero. Pointer arithmetic is base for indexing of array (discussed in later section). Arrays follow same naming schemes as variables name. Types of arrays : One Dimensional Array Two Dimensional Array Three Dimensional Array One Dimensional Arrays : One dimensional arrays are used to store multiple columns of data in a single row. * The address of elements inside array is in sequential form. * By default they have few things fixed : * No_of_Matrix = 1, No_of_Rows = 1 * 1-D Array : int age[10]; Syntax of 1-D array: You could ignore No_of_Matrix and No_of_Rows part, because they are default. int main() { datatype variable_name[No_of_columns]; or datatype variable_name[No_of_columns] = {values}; return 0; } Example of 1-D array : int main(int argc, char const *argv[]) { char name[10] = {'J','a','y','a','n','t','\\0'}; printf(\"first letter : %c\\n\",name[0]); printf(\"second letter : %c\\n\",name[1]); printf(\"third letter : %c\\n\",name[1]); printf(\"fourth letter : %c\\n\",name[1]); // printing via loop for(int i=0; i< 10; i++){ printf(\"%d | %d\\n\", i, name[i]); } return 0; } Memory Representation in case of 1-D : name { [][][][][][][][] [][][][][][][][] ........ 1 byte 1 byte } Here name is main container representing array. There are sub containers inside name array, 1 byte each representing char datatype. Two Dimensional Arrays : Two dimensional arrays are used to store multiple rows and columns of data in a single matrix. * The address of elements inside array is in sequential form. * By default they have few things fixed : * No_of_Matrix = 1, * 2-D Array : int ages[10][10]; Syntax of 2-D array: datatype variable_name[No_of_Rows][No_of_columns]; or datatype variable_name[No_of_Rows][No_of_columns] = {values}; Example of 2-D array : int main(int argc, char const *argv[]) { char matrix1[2][2] = {{1, 2},{4, 5}}; // printing via loop for(int i=0; i< 2; i++){ for (int j = 0; j < 2; j++) { printf(\"%d | %d = | %d |\\n\", i, j, matrix1[i][j]); } } return 0; } Memory Representation in case of 2-D : Multi Dimensional Arrays : Multi dimensional arrays are used to store multiple matrix of data in a sequential order. * Also known as 3 Dimensional Arrays * The address of matrices is in sequential form. * 3-D Array : int ages[2][10][10]; Syntax of 3-D array: datatype variable_name[No_of_Matrix][No_of_Rows][No_of_columns]; or datatype variable_name[No_of_Matrix][No_of_Rows][No_of_columns] = {values}; Example of 3-D array: int main() { int data[2][3][3] = { { {1,2,3}, {4,5,6}, {7,8,9} }, { {10,11,12}, {13,14,15}, {16,17,18} } }; printf(\"Matrix | Row | Column = Value\\n\"); //access data using loop. for(int matrix=0; matrix < 2; ++matrix){ for(int row=0; row < 3; ++row){ for(int col=0; col < 3; ++col){ printf(\"%6d | %6d | %6d = %6d\\n\", matrix, row, col, data[matrix][row][col]); } } } return 0; } Memory Representation in case of 3-D:","title":"08. Arrays"},{"location":"c/08-arrays/#arrays","text":"Arrays are used to store same kind of data in matrix form.","title":"Arrays :"},{"location":"c/08-arrays/#syntax-of-array","text":"datatype variable_name[No_of_Matrix][No_of_Rows][No_of_columns]; or datatype variable_name[No_of_Matrix][No_of_Rows][No_of_columns] = {value1, value2, value3};","title":"Syntax of array :"},{"location":"c/08-arrays/#example","text":"int main() { // 1-D Array int marks[100] = {1, 2, 3, 4, 5}; int length = sizeof(marks) / sizeof(marks[0]); // printing elements of array. for(int i=0; i<length; i++){ printf(\"%d\\t\",marks[i]); } return 0; }","title":"Example :"},{"location":"c/08-arrays/#few-important-points-about-arrays","text":"Indexing of array starts with zero. Pointer arithmetic is base for indexing of array (discussed in later section). Arrays follow same naming schemes as variables name.","title":"Few important points about arrays :"},{"location":"c/08-arrays/#types-of-arrays","text":"One Dimensional Array Two Dimensional Array Three Dimensional Array","title":"Types of arrays :"},{"location":"c/08-arrays/#one-dimensional-arrays","text":"One dimensional arrays are used to store multiple columns of data in a single row. * The address of elements inside array is in sequential form. * By default they have few things fixed : * No_of_Matrix = 1, No_of_Rows = 1 * 1-D Array : int age[10];","title":"One Dimensional Arrays :"},{"location":"c/08-arrays/#syntax-of-1-d-array","text":"You could ignore No_of_Matrix and No_of_Rows part, because they are default. int main() { datatype variable_name[No_of_columns]; or datatype variable_name[No_of_columns] = {values}; return 0; }","title":"Syntax of 1-D array:"},{"location":"c/08-arrays/#example-of-1-d-array","text":"int main(int argc, char const *argv[]) { char name[10] = {'J','a','y','a','n','t','\\0'}; printf(\"first letter : %c\\n\",name[0]); printf(\"second letter : %c\\n\",name[1]); printf(\"third letter : %c\\n\",name[1]); printf(\"fourth letter : %c\\n\",name[1]); // printing via loop for(int i=0; i< 10; i++){ printf(\"%d | %d\\n\", i, name[i]); } return 0; }","title":"Example of 1-D array :"},{"location":"c/08-arrays/#memory-representation-in-case-of-1-d","text":"name { [][][][][][][][] [][][][][][][][] ........ 1 byte 1 byte } Here name is main container representing array. There are sub containers inside name array, 1 byte each representing char datatype.","title":"Memory Representation in case of 1-D :"},{"location":"c/08-arrays/#two-dimensional-arrays","text":"Two dimensional arrays are used to store multiple rows and columns of data in a single matrix. * The address of elements inside array is in sequential form. * By default they have few things fixed : * No_of_Matrix = 1, * 2-D Array : int ages[10][10];","title":"Two Dimensional Arrays :"},{"location":"c/08-arrays/#syntax-of-2-d-array","text":"datatype variable_name[No_of_Rows][No_of_columns]; or datatype variable_name[No_of_Rows][No_of_columns] = {values};","title":"Syntax of 2-D array:"},{"location":"c/08-arrays/#example-of-2-d-array","text":"int main(int argc, char const *argv[]) { char matrix1[2][2] = {{1, 2},{4, 5}}; // printing via loop for(int i=0; i< 2; i++){ for (int j = 0; j < 2; j++) { printf(\"%d | %d = | %d |\\n\", i, j, matrix1[i][j]); } } return 0; }","title":"Example of 2-D array :"},{"location":"c/08-arrays/#memory-representation-in-case-of-2-d","text":"","title":"Memory Representation in case of 2-D :"},{"location":"c/08-arrays/#multi-dimensional-arrays","text":"Multi dimensional arrays are used to store multiple matrix of data in a sequential order. * Also known as 3 Dimensional Arrays * The address of matrices is in sequential form. * 3-D Array : int ages[2][10][10];","title":"Multi Dimensional Arrays :"},{"location":"c/08-arrays/#syntax-of-3-d-array","text":"datatype variable_name[No_of_Matrix][No_of_Rows][No_of_columns]; or datatype variable_name[No_of_Matrix][No_of_Rows][No_of_columns] = {values};","title":"Syntax of 3-D array:"},{"location":"c/08-arrays/#example-of-3-d-array","text":"int main() { int data[2][3][3] = { { {1,2,3}, {4,5,6}, {7,8,9} }, { {10,11,12}, {13,14,15}, {16,17,18} } }; printf(\"Matrix | Row | Column = Value\\n\"); //access data using loop. for(int matrix=0; matrix < 2; ++matrix){ for(int row=0; row < 3; ++row){ for(int col=0; col < 3; ++col){ printf(\"%6d | %6d | %6d = %6d\\n\", matrix, row, col, data[matrix][row][col]); } } } return 0; }","title":"Example of 3-D array:"},{"location":"c/08-arrays/#memory-representation-in-case-of-3-d","text":"","title":"Memory Representation in case of 3-D:"},{"location":"c/09-control-statements/","text":"Control Statements The statements that are used to control flow of execution of program are called as control statements. Types of Control Statements : Selection Control Structures Loop Control Structures Selection Control Structures : The control structures that allows us to execute actions based on a condition, provided by us, are called as selection control structures. Or, When the selected statements are executed based on some condition then selection control structures are used. Types of Selection Control Structures : if....else switch...case '?:' (terniary) if else selection control structure : if else control structure is used, when we need to execute some tasks, based on the expression, that results zero or non-zero value. Syntax of if : int main() { // syntax : if(expression_resulting_zero_or_non_zero){ // Note : Every non- zero number is treated as 1. // multiple expressions are allowed, seperated with commas. } // usage : if(0){ // statements inside body of if, will not execute. } // usage : if(1){ // statements inside body of if, will execute. } return 0; } Examples of if : int main() { int login_status = 0; // only if. if(login_status != 1){ printf(\"You are not allowed to access this system.\\n\"); } return 0; } int main() { int login_status = 0; //if with else if(login_status != 1){ printf(\"You are not allowed to access this system.\\n\"); } else { printf(\"Access granted..\\n\"); } return 0; } int main() { int login_status = 0; //if without else if(login_status != 1){ printf(\"You are not allowed to access this system.\\n\"); } if(login_status == 1) { printf(\"Access granted..\\n\"); } return 0; } int main() { int login_status = 0; //if with else if(login_status == 0){ printf(\"You are not allowed to access this system.\\n\"); } else if(login_status == 1){ printf(\"Access granted..\\n\"); } else{ printf(\"We have secured our system, from this hack.\\n\"); printf(\"Your identity have been reported to security agency.\\n\"); } return 0; } Notable Points about if...else in above example: else is a reserved keyword that is optional to use with if. else is used to connect another if with previous if. Multiple Expressions with if : We could use multiple expressions with if : Body of if is always evaluated as per the last value. int main() { if(0, 1, 0){ printf(\"I will not get printed.\\n\"); } if(1, 0, 1){ printf(\"I will get printed.\\n\"); } return 0; } Expression is always evaluated from left to right because, rule of Associativity of comma is left to right. int main() { if(printf(\"First\\n\"), printf(\"Second\\n\"), printf(\"Third\\n\")){ printf(\"Let's have a look in depth.\\n\"); } return 0; } Nested if When if statements is used inside body of another if, it is called nested if. int main() { if(1) { if(1){ // this is nested if printf(\"I am present inside body of if.\\n\"); } } } Switch Case Control Structure : switch case control structure is used, when we have possible combinations, prior to writing our c program. Example : Cities of students, studying in a school. Syntax : int main() { switch(expression_with_some_value) { case value : statements_to_execute; break; case value : statements_to_execute; break; default: statements_to_execute } return 0; } Example : int main() { switch(1){ case 1: printf(\"Value is 1\\n\"); break; case 2: printf(\"Value is 2\\n\"); break; default : printf(\"Value does not match any above case.\\n\"); } return 0; } Explanation of each part in switch case : int main() { int x = 10; switch(x){ case 1: printf(\"Hello\"); } // here x, is the value that will be used to match with every case. // os tries to match value of x with 1 and if both of them are found to be same, then printf(\"Hello\"); will be executed. return 0; } int main() { int roll_no = 2; switch(roll_no){ case 2 : printf(\"Student Name: Arnav\\n\"); break; // In above case break keyword is used to exit execution of switch case. // Means other cases after matching case will not be evaluated. } return 0; } int main() { int record_no = 10; switch(record_no){ case 1: printf(\"Name: Rahul, Salary : 1000\\n\"); break; case 2: printf(\"Name: Amit, Salary : 1000\\n\"); break; case 3: printf(\"Name: Suraj, Salary : 1000\\n\"); break; default : printf(\"Sorry, record not found.\\n\"); } return 0; } break is used to exit out of switch body. statements associated with default are executed only if, any of the above cases do not match. Ternary Control Structure : Ternary control structure is used, in place of if..else, In fact, it is short form of if..else. It is ternary operator. int main() { int marks = 10; int interview_eligibility = (marks > 60) ? 1 : 0; if(interview_eligibility) printf(\"Please visit administrator block at 6, for interview.\\n\"); else printf(\"You are not eligible for interview.\\n\"); return 0; }","title":"09. Control Statements"},{"location":"c/09-control-statements/#control-statements","text":"The statements that are used to control flow of execution of program are called as control statements.","title":"Control Statements"},{"location":"c/09-control-statements/#types-of-control-statements","text":"Selection Control Structures Loop Control Structures","title":"Types of Control Statements :"},{"location":"c/09-control-statements/#selection-control-structures","text":"The control structures that allows us to execute actions based on a condition, provided by us, are called as selection control structures. Or, When the selected statements are executed based on some condition then selection control structures are used.","title":"Selection Control Structures :"},{"location":"c/09-control-statements/#types-of-selection-control-structures","text":"if....else switch...case '?:' (terniary)","title":"Types of Selection Control Structures :"},{"location":"c/09-control-statements/#if-else-selection-control-structure","text":"if else control structure is used, when we need to execute some tasks, based on the expression, that results zero or non-zero value.","title":"if else selection control structure :"},{"location":"c/09-control-statements/#syntax-of-if","text":"int main() { // syntax : if(expression_resulting_zero_or_non_zero){ // Note : Every non- zero number is treated as 1. // multiple expressions are allowed, seperated with commas. } // usage : if(0){ // statements inside body of if, will not execute. } // usage : if(1){ // statements inside body of if, will execute. } return 0; }","title":"Syntax of if :"},{"location":"c/09-control-statements/#examples-of-if","text":"int main() { int login_status = 0; // only if. if(login_status != 1){ printf(\"You are not allowed to access this system.\\n\"); } return 0; } int main() { int login_status = 0; //if with else if(login_status != 1){ printf(\"You are not allowed to access this system.\\n\"); } else { printf(\"Access granted..\\n\"); } return 0; } int main() { int login_status = 0; //if without else if(login_status != 1){ printf(\"You are not allowed to access this system.\\n\"); } if(login_status == 1) { printf(\"Access granted..\\n\"); } return 0; } int main() { int login_status = 0; //if with else if(login_status == 0){ printf(\"You are not allowed to access this system.\\n\"); } else if(login_status == 1){ printf(\"Access granted..\\n\"); } else{ printf(\"We have secured our system, from this hack.\\n\"); printf(\"Your identity have been reported to security agency.\\n\"); } return 0; }","title":"Examples of if :"},{"location":"c/09-control-statements/#notable-points-about-ifelse-in-above-example","text":"else is a reserved keyword that is optional to use with if. else is used to connect another if with previous if.","title":"Notable Points about if...else in above example:"},{"location":"c/09-control-statements/#multiple-expressions-with-if","text":"We could use multiple expressions with if : Body of if is always evaluated as per the last value. int main() { if(0, 1, 0){ printf(\"I will not get printed.\\n\"); } if(1, 0, 1){ printf(\"I will get printed.\\n\"); } return 0; } Expression is always evaluated from left to right because, rule of Associativity of comma is left to right. int main() { if(printf(\"First\\n\"), printf(\"Second\\n\"), printf(\"Third\\n\")){ printf(\"Let's have a look in depth.\\n\"); } return 0; }","title":"Multiple Expressions with if :"},{"location":"c/09-control-statements/#nested-if","text":"When if statements is used inside body of another if, it is called nested if. int main() { if(1) { if(1){ // this is nested if printf(\"I am present inside body of if.\\n\"); } } }","title":"Nested if"},{"location":"c/09-control-statements/#switch-case-control-structure","text":"switch case control structure is used, when we have possible combinations, prior to writing our c program. Example : Cities of students, studying in a school. Syntax : int main() { switch(expression_with_some_value) { case value : statements_to_execute; break; case value : statements_to_execute; break; default: statements_to_execute } return 0; } Example : int main() { switch(1){ case 1: printf(\"Value is 1\\n\"); break; case 2: printf(\"Value is 2\\n\"); break; default : printf(\"Value does not match any above case.\\n\"); } return 0; }","title":"Switch Case Control Structure :"},{"location":"c/09-control-statements/#explanation-of-each-part-in-switch-case","text":"int main() { int x = 10; switch(x){ case 1: printf(\"Hello\"); } // here x, is the value that will be used to match with every case. // os tries to match value of x with 1 and if both of them are found to be same, then printf(\"Hello\"); will be executed. return 0; } int main() { int roll_no = 2; switch(roll_no){ case 2 : printf(\"Student Name: Arnav\\n\"); break; // In above case break keyword is used to exit execution of switch case. // Means other cases after matching case will not be evaluated. } return 0; } int main() { int record_no = 10; switch(record_no){ case 1: printf(\"Name: Rahul, Salary : 1000\\n\"); break; case 2: printf(\"Name: Amit, Salary : 1000\\n\"); break; case 3: printf(\"Name: Suraj, Salary : 1000\\n\"); break; default : printf(\"Sorry, record not found.\\n\"); } return 0; } break is used to exit out of switch body. statements associated with default are executed only if, any of the above cases do not match.","title":"Explanation of each part in  switch case :"},{"location":"c/09-control-statements/#ternary-control-structure","text":"Ternary control structure is used, in place of if..else, In fact, it is short form of if..else. It is ternary operator. int main() { int marks = 10; int interview_eligibility = (marks > 60) ? 1 : 0; if(interview_eligibility) printf(\"Please visit administrator block at 6, for interview.\\n\"); else printf(\"You are not eligible for interview.\\n\"); return 0; }","title":"Ternary Control Structure :"},{"location":"c/10-more-on-control-structures/","text":"Loop Control Structures : Loop control structures are used to perform repetitive tasks. Example : to print table for any user provided number. Loops can be infinite, make sure to end loop at some point. Types of Loop Control Structures : while do...while for while control structure : while control structure is used to execute repetitive tasks, till the condition provided evaluates to non-zero Syntax : int main() { while(expressions_that_evaluates_to_zero_or_non_zero){ // statements to execute. } return 0; } Example : int main() { int number = 10; int index = 1; // loop to print table of any number. while(number <= 10){ printf(\"%d x %d = %d\\n\", number, index, number * index); index++; } return 0; } int main() { while(1, 2, 0){ printf(\"Try to predict the output!\\n\"); } return 0; } do...while control structure : do while control structure is used when we need to execute some task prior to checking condition and till the condition is met. Syntax : int main() { do{ // statements to execute. }while(expression_that_results_zero_or_non_zero_value); return 0; } Example : int main() { int user_choice = 0; do{ printf(\"Choose a random number :\\t\"); scanf(\"%d\",&user_choice); }while(user_choice != rand() % 100); // rand() % 100 generates a random number between 0 and 100; return 0; } for Control Structure : for control structure is allows us to define initiation and final condition along with operation in same line. In older versions of C, initialization of variable is allowed only at top, but in ANSI C17, variable can be declared at time of usage. Syntax : int main() { for(initialization_expression; termination_expression; operation_expression){ // statements to execute. } return 0; } Example : int main() { // prints counting from 0 to 99. for(int i=0; i<100; i++){ printf(\"%d\\t\",i); } return 0; } All three initiation, termination and operation section of for are optional. for without initialization section : int main() { int i=0; for(; i<100; i++){ printf(\"%d\\t\",i); } return 0; } for without termination section : int main() { for(int number = 0; ; number++){ printf(\"%d\\t\", number); if(number >=99) break; } return 0; } for without operation section : int main() { for(int i=0; i<100; ){ printf(\"%d\\t\",i); i++; } return 0; } for without any section : int main() { int i = 0; for(;;){ if(i < 100) printf(\"%d\\t\",i++); } return 0; } Multiple expressions in for : int main() { int i=0; for(printf(\"initialization\\n\"), i = 0; printf(\"Condition Check\\n\"), i<5; printf(\"Operation\\n\"), i++){ printf(\"Inside body of if\\n\"); } return 0; } The above program verifies that we could have multiple expressions in if. the expressions are evaluated from left to right due to associativity of comma. Working of for : initialization Occurs Termination Condition is Checked Body is executed Operation section is executed, means value is incremented or decremented. int main() { int i=0; for(printf(\"initialization\\n\"), i = 0; printf(\"Condition Check\\n\"), i<5; printf(\"Operation\\n\"), i++){ printf(\"Inside body of if\\n\"); } return 0; }","title":"10. More on Control Statements"},{"location":"c/10-more-on-control-structures/#loop-control-structures","text":"Loop control structures are used to perform repetitive tasks. Example : to print table for any user provided number. Loops can be infinite, make sure to end loop at some point.","title":"Loop Control Structures :"},{"location":"c/10-more-on-control-structures/#types-of-loop-control-structures","text":"while do...while for","title":"Types of Loop Control Structures :"},{"location":"c/10-more-on-control-structures/#while-control-structure","text":"while control structure is used to execute repetitive tasks, till the condition provided evaluates to non-zero","title":"while control structure :"},{"location":"c/10-more-on-control-structures/#syntax","text":"int main() { while(expressions_that_evaluates_to_zero_or_non_zero){ // statements to execute. } return 0; }","title":"Syntax :"},{"location":"c/10-more-on-control-structures/#example","text":"int main() { int number = 10; int index = 1; // loop to print table of any number. while(number <= 10){ printf(\"%d x %d = %d\\n\", number, index, number * index); index++; } return 0; } int main() { while(1, 2, 0){ printf(\"Try to predict the output!\\n\"); } return 0; }","title":"Example :"},{"location":"c/10-more-on-control-structures/#dowhile-control-structure","text":"do while control structure is used when we need to execute some task prior to checking condition and till the condition is met.","title":"do...while control structure :"},{"location":"c/10-more-on-control-structures/#syntax_1","text":"int main() { do{ // statements to execute. }while(expression_that_results_zero_or_non_zero_value); return 0; }","title":"Syntax :"},{"location":"c/10-more-on-control-structures/#example_1","text":"int main() { int user_choice = 0; do{ printf(\"Choose a random number :\\t\"); scanf(\"%d\",&user_choice); }while(user_choice != rand() % 100); // rand() % 100 generates a random number between 0 and 100; return 0; }","title":"Example :"},{"location":"c/10-more-on-control-structures/#for-control-structure","text":"for control structure is allows us to define initiation and final condition along with operation in same line. In older versions of C, initialization of variable is allowed only at top, but in ANSI C17, variable can be declared at time of usage.","title":"for Control Structure :"},{"location":"c/10-more-on-control-structures/#syntax_2","text":"int main() { for(initialization_expression; termination_expression; operation_expression){ // statements to execute. } return 0; }","title":"Syntax :"},{"location":"c/10-more-on-control-structures/#example_2","text":"int main() { // prints counting from 0 to 99. for(int i=0; i<100; i++){ printf(\"%d\\t\",i); } return 0; } All three initiation, termination and operation section of for are optional.","title":"Example :"},{"location":"c/10-more-on-control-structures/#for-without-initialization-section","text":"int main() { int i=0; for(; i<100; i++){ printf(\"%d\\t\",i); } return 0; }","title":"for without initialization section :"},{"location":"c/10-more-on-control-structures/#for-without-termination-section","text":"int main() { for(int number = 0; ; number++){ printf(\"%d\\t\", number); if(number >=99) break; } return 0; }","title":"for without termination section :"},{"location":"c/10-more-on-control-structures/#for-without-operation-section","text":"int main() { for(int i=0; i<100; ){ printf(\"%d\\t\",i); i++; } return 0; }","title":"for without operation section :"},{"location":"c/10-more-on-control-structures/#for-without-any-section","text":"int main() { int i = 0; for(;;){ if(i < 100) printf(\"%d\\t\",i++); } return 0; }","title":"for without any section :"},{"location":"c/10-more-on-control-structures/#multiple-expressions-in-for","text":"int main() { int i=0; for(printf(\"initialization\\n\"), i = 0; printf(\"Condition Check\\n\"), i<5; printf(\"Operation\\n\"), i++){ printf(\"Inside body of if\\n\"); } return 0; } The above program verifies that we could have multiple expressions in if. the expressions are evaluated from left to right due to associativity of comma.","title":"Multiple expressions in for :"},{"location":"c/10-more-on-control-structures/#working-of-for","text":"initialization Occurs Termination Condition is Checked Body is executed Operation section is executed, means value is incremented or decremented. int main() { int i=0; for(printf(\"initialization\\n\"), i = 0; printf(\"Condition Check\\n\"), i<5; printf(\"Operation\\n\"), i++){ printf(\"Inside body of if\\n\"); } return 0; }","title":"Working of for :"},{"location":"c/11-functions/","text":"Functions in C : functions are containers that help reduce duplicacy of code make code reusable at different positions in our program. Keeps program modular and seperates logic of program in seperate blocks. Types of Functions : User defined functions. Built in functions. Note : In reality in c programming only user defined functions exist but for writing in exams if you are in india, then write both types. User Defined Functions : These functions are defined by developer itself. example : int max(int a, int b){ return (a>b) ? a : b; } Built in Functions : These are the functions defined by creator of c and are used by developers. example : int main() { //built in function printf(\"i am built in function of c\"); return 0; } Function Invokation : Steps to call a function in our program is called function invocation. example: int main(){ max(1, 3); // invoked max function return 0; } Nested Function : Nesting of functions is possible in c. Nested functions are functions declared/invoked within other function functions. Rules for Functions : Variable name rules are same for function naming rules. Function Arguments are optional. Function return type could be void. By default a function in c returns int as datatype. return keyword is used to send response back from function. Syntax of Function : return_type function_name( arguments ) { // body of function. } Examples of Function : //function returning void. void print_letters (char c) { for( int i = 0; i <= 10; i++) { printf(\"%c\\n\",c); } } // function return int as return type. int max( int a, int b ) { return (a>b) ? a : b ; } // function with no arguments void drawcircle() { printf(\"I am drawing circle\\n\"); circle(100,100,30); } Function Arguments : Actual Arguments Formal Arguments Formal Arguments : These are the declarations within user defined functions. example : int max( int a, int b ) // formal arguments. { return ( a > b ) ? a : b ; } Actual Arguments : These are values passed during invocation of function. example : int main(){ max( 2, 4 ); // actual arguments. return 0; } Expression Evaluation in Function Invocation: Expressions passed in functions are always evaluated form right to left. example : int sum( int a, int b) { return a + b ; } int main() { int result = sum ( printf(\"abc\"); , printf(\"def\") ); printf(\"\\tResult is %d \", result ); return 0; } Output will be : defabc Result is 6 Expression evaluation in Function Definition : In case of function declaration expression evaluation does not exist. In case of function definition values are assigned/declared from left to right. example : int multiply(int a, int b) { return a * b ; } Some practice for functions : Find Output of program : int max ( int a , int b ) { return ( a > b ) ? a : b ; } int main() { int number = 10; int result = max ( ++a , ++a ); // result = ? return 0; } Find Max of four numbers : int max ( int a, int b ) { return ( a > b ) ? a : b ; } int main() { int first = 10; int second = 12; int third = 20; int fourth = 22; // code for max. int result = max( max(first, second) , max(third, fourth) ) ; printf(\" Maximum value is %d \\n\", result ) ; return 0; } Program to print letters in increasing order. void pattern(char c, int times) { for(int i = 0; i <= times; i++){ for(int j =0; j <= i; j++){ printf(\"%c\",c); } printf(\"\\n\"); } } int main() { pattern('$', 5); pattern('\u00db', 7); return 0; }","title":"11. Functions"},{"location":"c/11-functions/#functions-in-c","text":"functions are containers that help reduce duplicacy of code make code reusable at different positions in our program. Keeps program modular and seperates logic of program in seperate blocks.","title":"Functions in C :"},{"location":"c/11-functions/#types-of-functions","text":"User defined functions. Built in functions. Note : In reality in c programming only user defined functions exist but for writing in exams if you are in india, then write both types.","title":"Types of Functions :"},{"location":"c/11-functions/#user-defined-functions","text":"These functions are defined by developer itself. example : int max(int a, int b){ return (a>b) ? a : b; }","title":"User Defined Functions :"},{"location":"c/11-functions/#built-in-functions","text":"These are the functions defined by creator of c and are used by developers. example : int main() { //built in function printf(\"i am built in function of c\"); return 0; }","title":"Built in Functions :"},{"location":"c/11-functions/#function-invokation","text":"Steps to call a function in our program is called function invocation. example: int main(){ max(1, 3); // invoked max function return 0; }","title":"Function Invokation :"},{"location":"c/11-functions/#nested-function","text":"Nesting of functions is possible in c. Nested functions are functions declared/invoked within other function functions.","title":"Nested Function :"},{"location":"c/11-functions/#rules-for-functions","text":"Variable name rules are same for function naming rules. Function Arguments are optional. Function return type could be void. By default a function in c returns int as datatype. return keyword is used to send response back from function.","title":"Rules for Functions :"},{"location":"c/11-functions/#syntax-of-function","text":"return_type function_name( arguments ) { // body of function. }","title":"Syntax of Function :"},{"location":"c/11-functions/#examples-of-function","text":"//function returning void. void print_letters (char c) { for( int i = 0; i <= 10; i++) { printf(\"%c\\n\",c); } } // function return int as return type. int max( int a, int b ) { return (a>b) ? a : b ; } // function with no arguments void drawcircle() { printf(\"I am drawing circle\\n\"); circle(100,100,30); }","title":"Examples of Function :"},{"location":"c/11-functions/#function-arguments","text":"Actual Arguments Formal Arguments","title":"Function Arguments :"},{"location":"c/11-functions/#formal-arguments","text":"These are the declarations within user defined functions. example : int max( int a, int b ) // formal arguments. { return ( a > b ) ? a : b ; }","title":"Formal Arguments :"},{"location":"c/11-functions/#actual-arguments","text":"These are values passed during invocation of function. example : int main(){ max( 2, 4 ); // actual arguments. return 0; }","title":"Actual Arguments :"},{"location":"c/11-functions/#expression-evaluation-in-function-invocation","text":"Expressions passed in functions are always evaluated form right to left. example : int sum( int a, int b) { return a + b ; } int main() { int result = sum ( printf(\"abc\"); , printf(\"def\") ); printf(\"\\tResult is %d \", result ); return 0; }","title":"Expression Evaluation in Function Invocation:"},{"location":"c/11-functions/#output-will-be-defabc-result-is-6","text":"","title":"Output will be  : defabc      Result is 6"},{"location":"c/11-functions/#expression-evaluation-in-function-definition","text":"In case of function declaration expression evaluation does not exist. In case of function definition values are assigned/declared from left to right. example : int multiply(int a, int b) { return a * b ; }","title":"Expression evaluation in Function Definition :"},{"location":"c/11-functions/#some-practice-for-functions","text":"","title":"Some practice for functions :"},{"location":"c/11-functions/#find-output-of-program","text":"int max ( int a , int b ) { return ( a > b ) ? a : b ; } int main() { int number = 10; int result = max ( ++a , ++a ); // result = ? return 0; }","title":"Find Output of program :"},{"location":"c/11-functions/#find-max-of-four-numbers","text":"int max ( int a, int b ) { return ( a > b ) ? a : b ; } int main() { int first = 10; int second = 12; int third = 20; int fourth = 22; // code for max. int result = max( max(first, second) , max(third, fourth) ) ; printf(\" Maximum value is %d \\n\", result ) ; return 0; }","title":"Find Max of four numbers :"},{"location":"c/11-functions/#program-to-print-letters-in-increasing-order","text":"void pattern(char c, int times) { for(int i = 0; i <= times; i++){ for(int j =0; j <= i; j++){ printf(\"%c\",c); } printf(\"\\n\"); } } int main() { pattern('$', 5); pattern('\u00db', 7); return 0; }","title":"Program to print letters in increasing order."},{"location":"c/12-pointers/","text":"Pointers in C : Pointers are special kind of variables which stores memory address of another variables. Syntax of Pointers : datatype *variable_name; or datatype *variable_name = value; Uses of Pointers : Manipulate data present at some specific memory address. Increases scope of variables. Provides multiple names to single variable. Provides a way to create arrays in C. Dennis Ritche created arrays with help of pointers. Pointers are used to manipulate constant variable value. Memory allocation in case of pointers : Memory is allocated by Compiler. | Compiler | Memory| |----------|-------- | 16 - BIT | 2 BYTES | | 32 - BIT | 4 BYTES | | 64 - BIT | 8 BYTES | Example : int main() { char * ptr1; int * ptr2; float * ptr3; double * ptr4; printf(\"char : %lu, int : %lu, float : %lu, double : %lu\\n\", sizeof(ptr1), sizeof(ptr2), sizeof(ptr3), sizeof(ptr4) ); return 0; } Examples of pointers : int main(){ int number = 10; int *ptr; // declaration ptr = &number; // initialization // getting address of variable printf(\"address of number %u\\n\",&number); // accessing value of pointer. printf(\"Value in pointer %u\\n\",ptr); return 0; } De-referencing Pointers : Dereferencing is process of getting value stored at some memory location with help of pointers. or Dereferencing is process of getting value of a variable by using memory address stored in pointer. Uses of Dereferencing : Dereferencing is Used to read or write data of memory location stored inside pointer. Example : int *number = 10; // changes value of number to 10. Examples of Dereferencing : int main(){ int marks = 10; int *ptr = &marks; printf(\"Marks are %d\\n\", *ptr); // *ptr is dereferencing pointer to marks. return 0; }","title":"12. Pointers"},{"location":"c/12-pointers/#pointers-in-c","text":"Pointers are special kind of variables which stores memory address of another variables.","title":"Pointers in C :"},{"location":"c/12-pointers/#syntax-of-pointers","text":"datatype *variable_name; or datatype *variable_name = value;","title":"Syntax of Pointers :"},{"location":"c/12-pointers/#uses-of-pointers","text":"Manipulate data present at some specific memory address. Increases scope of variables. Provides multiple names to single variable. Provides a way to create arrays in C. Dennis Ritche created arrays with help of pointers. Pointers are used to manipulate constant variable value.","title":"Uses of Pointers :"},{"location":"c/12-pointers/#memory-allocation-in-case-of-pointers","text":"Memory is allocated by Compiler. | Compiler | Memory| |----------|-------- | 16 - BIT | 2 BYTES | | 32 - BIT | 4 BYTES | | 64 - BIT | 8 BYTES | Example : int main() { char * ptr1; int * ptr2; float * ptr3; double * ptr4; printf(\"char : %lu, int : %lu, float : %lu, double : %lu\\n\", sizeof(ptr1), sizeof(ptr2), sizeof(ptr3), sizeof(ptr4) ); return 0; }","title":"Memory allocation in case of pointers :"},{"location":"c/12-pointers/#examples-of-pointers","text":"int main(){ int number = 10; int *ptr; // declaration ptr = &number; // initialization // getting address of variable printf(\"address of number %u\\n\",&number); // accessing value of pointer. printf(\"Value in pointer %u\\n\",ptr); return 0; }","title":"Examples of pointers :"},{"location":"c/12-pointers/#de-referencing-pointers","text":"Dereferencing is process of getting value stored at some memory location with help of pointers. or Dereferencing is process of getting value of a variable by using memory address stored in pointer.","title":"De-referencing Pointers :"},{"location":"c/12-pointers/#uses-of-dereferencing","text":"Dereferencing is Used to read or write data of memory location stored inside pointer. Example : int *number = 10; // changes value of number to 10.","title":"Uses of Dereferencing :"},{"location":"c/12-pointers/#examples-of-dereferencing","text":"int main(){ int marks = 10; int *ptr = &marks; printf(\"Marks are %d\\n\", *ptr); // *ptr is dereferencing pointer to marks. return 0; }","title":"Examples of Dereferencing :"},{"location":"c/13-more-on-functions/","text":"Stack Concept : STACK is a part in RAM reserved by OS to keep account of program. OS manages program execution with the help of STACK. OS stores program execution in STACK. Top most stack section is always executed first. Once a function execution finishes STACK memory is cleaned for that specific function (removal is called as pop) Concept of STACK with function calls : Best way to understand the concept is to see it in action. Example : int max(int a, int b){ return (a >b) ? a : b; } int main(){ int firstNumber = 0; int SecondNumber = 0; printf(\"Enter First Number: \"); scanf(\"%d\",&firstNumber); printf(\"Enter Second Number: \"); scanf(\"%d\",&secondNumber); int result = max(firstNumber, secondNumber); printf(\"Maximum of %d and %d is : %d\\n\",firstNumber,secondNumber,result); return 0; } Steps of Execution are : Main function is loaded in STACK. Local variables are created in STACK. Value is assigned to local variables. Value of address from where program left execution is stored in register. For printf seperate STACK section is created, because it is a function. Now printf execution completed, so STACK memory for printf is popped. Again program continues execution from main function. scanf is a function so, seperate STACK section is created for it. scanf execution completes with some value assigned to variable, so STACK memory is popped again. Steps 4 to 9 repeats again for second number input. Program Execution leaving address is again stored in STACK or register.(but for now say stack) Now max function is created in STACK, with two variables a and b. Values from main function are copied in max function. Program calculates result based on condition. Value is returned to main function and STACK is popped. and so on...... the process continues till end of program. Note : Only USER-DEFINED functions are shown in images. //Add image here. Why is main function declared with int return type? Every program has to return some value back to Operating System This information is stored in a variable, named errorlevel (in case of windows only) View info of this variable using : echo %errorlevel% (on windows) The above case can also be detected by using debugger because improper termination of program creates a dump file. Call by Reference functions : The functions that takes pointer as formal argument and address as actual argument are called as call by reference functions. int sum(const int * first, const int * second){ return first + second; } int main(int argc, char const *argv[]) { int num1 = 10 , num2 = 20; int result = sum(&num1, &num2); printf(\"%d + %d = %d\\n\", num1, num2, result); return 0; } Notable points about call by reference : There is formation of one variable as pointer in stack. Size of pointer depends on bits of compiler . (16bit - 1 byte), (32bit - 4 bytes), (64bit - 8 bytes). In case of passing arrays to functions this method saves lot of memory space and processor computing power. Sample 1 : void print(char name[], int salary){ printf(\"Your name is %s and monthly pay is %d\", name, salary); } int main(int argc, char const *argv[]) { char name[20] = \"Jayant Malik\"; print(name, 20000); return 0; } // Memory Usage by print : 20 bytes for name + 4 bytes for int(64 bit compiler). Sample 2 : void print(const char *name, int salary){ printf(\"Your name is %s and monthly pay is %d\", name, salary); } int main(int argc, char const *argv[]) { print(\"Jayant Malik\", 20000); return 0; } //memory usage by print : 8 bytes for name + 4 bytes for int. Call by Value Functions : Functions that takes original datatype as actual argument and direct values as actual argument. int sum(int first, int second){ return first + second; } int main(int argc, char const *argv[]) { int result = sum(10, 20); printf(\"10 + 20 = %d\\n\", result); return 0; } Notable points about Call by value functions : Actual value of variable is copied in stack. Not access to change value of variable in local scope of parent calling function. In case of array extra memory usage takes place. Nested function declaration : when a function is declared inside function then it is called as nested function declaration. int main(int argc, char const *argv[]) { int sum(int a, int b){ return a + b; } int result = sum(10, 20); printf(\"10 + 20 = %d\\n\",result); return 0; } Recursive function : when same function again from same calling function then it is called recursion. Output of recursion is determined using stack. void temp(int number){ number--; if(number > 0){ temp(num); } } int main(int argc, char const *argv[]) { temp(3); return 0; }","title":"13. More on Functions"},{"location":"c/13-more-on-functions/#stack-concept","text":"STACK is a part in RAM reserved by OS to keep account of program. OS manages program execution with the help of STACK. OS stores program execution in STACK. Top most stack section is always executed first. Once a function execution finishes STACK memory is cleaned for that specific function (removal is called as pop)","title":"Stack Concept :"},{"location":"c/13-more-on-functions/#concept-of-stack-with-function-calls","text":"Best way to understand the concept is to see it in action.","title":"Concept of STACK with function calls :"},{"location":"c/13-more-on-functions/#example","text":"int max(int a, int b){ return (a >b) ? a : b; } int main(){ int firstNumber = 0; int SecondNumber = 0; printf(\"Enter First Number: \"); scanf(\"%d\",&firstNumber); printf(\"Enter Second Number: \"); scanf(\"%d\",&secondNumber); int result = max(firstNumber, secondNumber); printf(\"Maximum of %d and %d is : %d\\n\",firstNumber,secondNumber,result); return 0; }","title":"Example :"},{"location":"c/13-more-on-functions/#steps-of-execution-are","text":"Main function is loaded in STACK. Local variables are created in STACK. Value is assigned to local variables. Value of address from where program left execution is stored in register. For printf seperate STACK section is created, because it is a function. Now printf execution completed, so STACK memory for printf is popped. Again program continues execution from main function. scanf is a function so, seperate STACK section is created for it. scanf execution completes with some value assigned to variable, so STACK memory is popped again. Steps 4 to 9 repeats again for second number input. Program Execution leaving address is again stored in STACK or register.(but for now say stack) Now max function is created in STACK, with two variables a and b. Values from main function are copied in max function. Program calculates result based on condition. Value is returned to main function and STACK is popped. and so on...... the process continues till end of program.","title":"Steps of Execution are :"},{"location":"c/13-more-on-functions/#note-only-user-defined-functions-are-shown-in-images","text":"","title":"Note : Only USER-DEFINED functions are shown in images."},{"location":"c/13-more-on-functions/#add-image-here","text":"","title":"//Add image here."},{"location":"c/13-more-on-functions/#why-is-main-function-declared-with-int-return-type","text":"Every program has to return some value back to Operating System This information is stored in a variable, named errorlevel (in case of windows only) View info of this variable using : echo %errorlevel% (on windows)","title":"Why is main function declared with int return type?"},{"location":"c/13-more-on-functions/#the-above-case-can-also-be-detected-by-using-debugger-because-improper-termination-of-program-creates-a-dump-file","text":"","title":"The above case can also be detected by using debugger because improper termination of program creates a dump file."},{"location":"c/13-more-on-functions/#call-by-reference-functions","text":"The functions that takes pointer as formal argument and address as actual argument are called as call by reference functions. int sum(const int * first, const int * second){ return first + second; } int main(int argc, char const *argv[]) { int num1 = 10 , num2 = 20; int result = sum(&num1, &num2); printf(\"%d + %d = %d\\n\", num1, num2, result); return 0; }","title":"Call by Reference functions :"},{"location":"c/13-more-on-functions/#notable-points-about-call-by-reference","text":"There is formation of one variable as pointer in stack. Size of pointer depends on bits of compiler . (16bit - 1 byte), (32bit - 4 bytes), (64bit - 8 bytes). In case of passing arrays to functions this method saves lot of memory space and processor computing power.","title":"Notable points about call by reference :"},{"location":"c/13-more-on-functions/#sample-1","text":"void print(char name[], int salary){ printf(\"Your name is %s and monthly pay is %d\", name, salary); } int main(int argc, char const *argv[]) { char name[20] = \"Jayant Malik\"; print(name, 20000); return 0; } // Memory Usage by print : 20 bytes for name + 4 bytes for int(64 bit compiler).","title":"Sample 1 :"},{"location":"c/13-more-on-functions/#sample-2","text":"void print(const char *name, int salary){ printf(\"Your name is %s and monthly pay is %d\", name, salary); } int main(int argc, char const *argv[]) { print(\"Jayant Malik\", 20000); return 0; } //memory usage by print : 8 bytes for name + 4 bytes for int.","title":"Sample 2 :"},{"location":"c/13-more-on-functions/#call-by-value-functions","text":"Functions that takes original datatype as actual argument and direct values as actual argument. int sum(int first, int second){ return first + second; } int main(int argc, char const *argv[]) { int result = sum(10, 20); printf(\"10 + 20 = %d\\n\", result); return 0; }","title":"Call by Value Functions :"},{"location":"c/13-more-on-functions/#notable-points-about-call-by-value-functions","text":"Actual value of variable is copied in stack. Not access to change value of variable in local scope of parent calling function. In case of array extra memory usage takes place.","title":"Notable points about Call by value functions :"},{"location":"c/13-more-on-functions/#nested-function-declaration","text":"when a function is declared inside function then it is called as nested function declaration. int main(int argc, char const *argv[]) { int sum(int a, int b){ return a + b; } int result = sum(10, 20); printf(\"10 + 20 = %d\\n\",result); return 0; }","title":"Nested function declaration :"},{"location":"c/13-more-on-functions/#recursive-function","text":"when same function again from same calling function then it is called recursion. Output of recursion is determined using stack. void temp(int number){ number--; if(number > 0){ temp(num); } } int main(int argc, char const *argv[]) { temp(3); return 0; }","title":"Recursive function :"},{"location":"c/14-preprocessor-directives/","text":"Preprocessor Directives : Preprocessor directives are special kind of c statements, that are processed during compilation of c program. Types of Preprocessor directives : File inclusion preprocessor Macro preprocessor Conditional preprocessor Preprocessor : preprocessor tells compiler about some special kind of action to execute. preprocessor directives are started with # symbol. File inclusion preprocessor : File inclusion preprocessor directives are used to include some other c file in our program code file. File inclusions are included using #include keyword. File inclusion preprocessor can be included in any scope (global or local). code from other file is copied in your main program file during compilation. Syntax of file inclusion preprocessor : #include<filename> or #include \"filename\" Difference in double and single quotes inclusions: \"\" are searches file in current directory and then searches in include directory (if not found in current path). <> searches file in include directory. Rules of file preprocessor : Single inclusion per line is allowed only. No two files can be included in single line.(others are discarded in any.) Semicolons are not used with file preprocessor. Absolute path can be used to include preprocessor. (/home/jayant/file.c) Short path is not allowed. (~/temp/file.c) Why to use preprocessor : preprocessor are used to include instructions written in some other file into our main program file. Errors in Preprocessors : Program 1 : //----------------------temp.c file---------------- printf(\"Hello from program.c\"); //----------------------program.c------------------ #include \"temp.c\" // not allowed because only declarative statements are allowed in global scope. int main(){ printf(\"in beginning of main...\\n\"); #include<temp.c> // error because file not present in // include directory. #include \"temp.c\" // replaced by printf(\"Hello from program.c\"); // during compilation. return 0; } Program 2 : //--------------------temp.c--------------------- int sum(const int *const num1, const int * const num2){ return *num1 + *num2; } //-------------------program.c------------------ #include \"temp.c\" int main(){ int num1 = 10, num2 = 20; int result = sum(&num1, &num2); printf(\"Result is %d\\n\",result); return 0; } Conclusions from File inclusion preprocessor: keep scope of code in mind of temp.c file because code from temp.c file will be substituted in program.c file. use \"\" or <> syntax as per directory, which stores your .c file. What happens during compilation : temp.c ------> compiler -----> .obj file program.c ----> compiler -----> .exe file / .out file What dennis ritche did : He wrote saveral .c files that contained his c code. He injected .obj file to .lib or .dll file. When compiler linker does its action during compilation time, then he checks .lib or .dll file.. Now we uses printf function that is injected somewhere in .lib file. Difference between dll and lib file : Dll files load limited contents of code to memory as required by program. lib file loads all code to memory whether it is required or not. How to inject file to .lib or .dll file using turboc++ ? Navigate to BIN directory. using tslib.exe inject .obj file to .lib file command : tslib ../lib/CS.lib + sample.obj Header Files in C : Now, We injected our .obj file to .lib file then, question arises how will user know what are functions defined in .lib file. Header files are simple text files with .h extension used to define function prototypes and macro definition. Header files are used to tell developer about which functions are declared in .lib file. Header files do not contain any program logic. it only contains function prototype which tells us few things : 1. Name of function 2. Return value of function 3. Inputs required by function. Creating function prototype in a header file (sample code): int cdecl sum(const int *num1, const int *num2); Some terms in header file : cdecl ---> specifies that function was purely written in c language syntax. (c declarative) Macro Preprocessor : Macro preprocessor is used to define a custom name for any operator or statement. it reduces duplicate code. it helps to call multiple statements of c using a single macro name. There is no stack formation in case of macro, these are c statements that are replaced in code during compilation with their values. Syntax to declare macro : #define macro_name value_or_statements Example of macro : #define PI 3.14 #define NAME printf(\"Hello\"); printf(\"Jayant\"); Types of MACROS : Simple Macro without Argument. it do not have any arguments as functions have. Argument Macro it has arguments that are replaced by values. Example of Simple Macro : #define PI 3.14 #define Age 20 Syntax of Argument Macro : #define sum(x,y) x+y #define multiply(a,b) a*b Note : In case of argument macro there is no formation of stack. Example of Macro : Program 1 : #define PI 3.14 int main(){ int pi_square = PI * PI; //int pi_square = 3.14 * 3.14; printf(\"value of PI is %f\\n\",pi_square); return 0; } Program 2 : #define AND && int main(){ int age = 10; if( (age > 5) AND (age < 19)) printf(\"Congrats you won a laptop.\\n\"); else printf(\"You won a titanic ship.\\n\"); return 0; } Program 3 : #define sum(a,b) a+b int main(){ long double first, second; printf(\"Enter first number:\\t\"); scanf(\"%Le\",&first); // 10 printf(\"Enter second number:\\t\"); scanf(\"%Le\",&second); // 20 long double result = sum(first,second); // int result = 10 + 20 ; printf(\"Result is %Lf\\n\",result); //result = 30 return 0; }","title":"14. Preprocessor Directives"},{"location":"c/14-preprocessor-directives/#preprocessor-directives","text":"Preprocessor directives are special kind of c statements, that are processed during compilation of c program.","title":"Preprocessor Directives :"},{"location":"c/14-preprocessor-directives/#types-of-preprocessor-directives","text":"File inclusion preprocessor Macro preprocessor Conditional preprocessor","title":"Types of Preprocessor directives :"},{"location":"c/14-preprocessor-directives/#preprocessor","text":"preprocessor tells compiler about some special kind of action to execute. preprocessor directives are started with # symbol.","title":"Preprocessor :"},{"location":"c/14-preprocessor-directives/#file-inclusion-preprocessor","text":"File inclusion preprocessor directives are used to include some other c file in our program code file. File inclusions are included using #include keyword. File inclusion preprocessor can be included in any scope (global or local). code from other file is copied in your main program file during compilation.","title":"File inclusion preprocessor :"},{"location":"c/14-preprocessor-directives/#syntax-of-file-inclusion-preprocessor","text":"#include<filename> or #include \"filename\"","title":"Syntax of file inclusion preprocessor :"},{"location":"c/14-preprocessor-directives/#difference-in-double-and-single-quotes-inclusions","text":"\"\" are searches file in current directory and then searches in include directory (if not found in current path). <> searches file in include directory.","title":"Difference in double and single quotes inclusions:"},{"location":"c/14-preprocessor-directives/#rules-of-file-preprocessor","text":"Single inclusion per line is allowed only. No two files can be included in single line.(others are discarded in any.) Semicolons are not used with file preprocessor. Absolute path can be used to include preprocessor. (/home/jayant/file.c) Short path is not allowed. (~/temp/file.c)","title":"Rules of file preprocessor :"},{"location":"c/14-preprocessor-directives/#why-to-use-preprocessor","text":"preprocessor are used to include instructions written in some other file into our main program file.","title":"Why to use preprocessor :"},{"location":"c/14-preprocessor-directives/#errors-in-preprocessors","text":"","title":"Errors in Preprocessors :"},{"location":"c/14-preprocessor-directives/#program-1","text":"//----------------------temp.c file---------------- printf(\"Hello from program.c\"); //----------------------program.c------------------ #include \"temp.c\" // not allowed because only declarative statements are allowed in global scope. int main(){ printf(\"in beginning of main...\\n\"); #include<temp.c> // error because file not present in // include directory. #include \"temp.c\" // replaced by printf(\"Hello from program.c\"); // during compilation. return 0; }","title":"Program 1 :"},{"location":"c/14-preprocessor-directives/#program-2","text":"//--------------------temp.c--------------------- int sum(const int *const num1, const int * const num2){ return *num1 + *num2; } //-------------------program.c------------------ #include \"temp.c\" int main(){ int num1 = 10, num2 = 20; int result = sum(&num1, &num2); printf(\"Result is %d\\n\",result); return 0; }","title":"Program 2 :"},{"location":"c/14-preprocessor-directives/#conclusions-from-file-inclusion-preprocessor","text":"keep scope of code in mind of temp.c file because code from temp.c file will be substituted in program.c file. use \"\" or <> syntax as per directory, which stores your .c file.","title":"Conclusions from File inclusion preprocessor:"},{"location":"c/14-preprocessor-directives/#what-happens-during-compilation","text":"temp.c ------> compiler -----> .obj file program.c ----> compiler -----> .exe file / .out file","title":"What happens during compilation :"},{"location":"c/14-preprocessor-directives/#what-dennis-ritche-did","text":"He wrote saveral .c files that contained his c code. He injected .obj file to .lib or .dll file. When compiler linker does its action during compilation time, then he checks .lib or .dll file.. Now we uses printf function that is injected somewhere in .lib file.","title":"What dennis ritche did :"},{"location":"c/14-preprocessor-directives/#difference-between-dll-and-lib-file","text":"Dll files load limited contents of code to memory as required by program. lib file loads all code to memory whether it is required or not.","title":"Difference between dll and lib file :"},{"location":"c/14-preprocessor-directives/#how-to-inject-file-to-lib-or-dll-file-using-turboc","text":"Navigate to BIN directory. using tslib.exe inject .obj file to .lib file command : tslib ../lib/CS.lib + sample.obj","title":"How to inject file to .lib or .dll file using turboc++ ?"},{"location":"c/14-preprocessor-directives/#header-files-in-c","text":"Now, We injected our .obj file to .lib file then, question arises how will user know what are functions defined in .lib file. Header files are simple text files with .h extension used to define function prototypes and macro definition. Header files are used to tell developer about which functions are declared in .lib file. Header files do not contain any program logic. it only contains function prototype which tells us few things : 1. Name of function 2. Return value of function 3. Inputs required by function.","title":"Header Files in C :"},{"location":"c/14-preprocessor-directives/#creating-function-prototype-in-a-header-file-sample-code","text":"int cdecl sum(const int *num1, const int *num2);","title":"Creating function prototype in a header file (sample code):"},{"location":"c/14-preprocessor-directives/#some-terms-in-header-file","text":"cdecl ---> specifies that function was purely written in c language syntax. (c declarative)","title":"Some terms in header file :"},{"location":"c/14-preprocessor-directives/#macro-preprocessor","text":"Macro preprocessor is used to define a custom name for any operator or statement. it reduces duplicate code. it helps to call multiple statements of c using a single macro name. There is no stack formation in case of macro, these are c statements that are replaced in code during compilation with their values.","title":"Macro Preprocessor :"},{"location":"c/14-preprocessor-directives/#syntax-to-declare-macro","text":"#define macro_name value_or_statements","title":"Syntax to declare macro :"},{"location":"c/14-preprocessor-directives/#example-of-macro","text":"#define PI 3.14 #define NAME printf(\"Hello\"); printf(\"Jayant\");","title":"Example of macro :"},{"location":"c/14-preprocessor-directives/#types-of-macros","text":"Simple Macro without Argument. it do not have any arguments as functions have. Argument Macro it has arguments that are replaced by values.","title":"Types of MACROS :"},{"location":"c/14-preprocessor-directives/#example-of-simple-macro","text":"#define PI 3.14 #define Age 20","title":"Example of Simple Macro :"},{"location":"c/14-preprocessor-directives/#syntax-of-argument-macro","text":"#define sum(x,y) x+y #define multiply(a,b) a*b","title":"Syntax of Argument Macro :"},{"location":"c/14-preprocessor-directives/#note-in-case-of-argument-macro-there-is-no-formation-of-stack","text":"","title":"Note : In case of argument macro there is no formation of stack."},{"location":"c/14-preprocessor-directives/#example-of-macro_1","text":"","title":"Example of Macro :"},{"location":"c/14-preprocessor-directives/#program-1_1","text":"#define PI 3.14 int main(){ int pi_square = PI * PI; //int pi_square = 3.14 * 3.14; printf(\"value of PI is %f\\n\",pi_square); return 0; }","title":"Program 1 :"},{"location":"c/14-preprocessor-directives/#program-2_1","text":"#define AND && int main(){ int age = 10; if( (age > 5) AND (age < 19)) printf(\"Congrats you won a laptop.\\n\"); else printf(\"You won a titanic ship.\\n\"); return 0; }","title":"Program 2 :"},{"location":"c/14-preprocessor-directives/#program-3","text":"#define sum(a,b) a+b int main(){ long double first, second; printf(\"Enter first number:\\t\"); scanf(\"%Le\",&first); // 10 printf(\"Enter second number:\\t\"); scanf(\"%Le\",&second); // 20 long double result = sum(first,second); // int result = 10 + 20 ; printf(\"Result is %Lf\\n\",result); //result = 30 return 0; }","title":"Program 3 :"},{"location":"c/15-more-on-preprocessor/","text":"Conditional Preprocessor : These are used to perform inclusion of file based on some condition. keywords related to conditional preprocessor : Sr. keyword Full Form Usage 1 #ifdef if defined used to check whether a macro is declared previously. 2 #ifndef if not defined used to check whether a macro is not declared previously. 3 #undef undefine used to undefine a previous defined macro. 4 #endif end if used to terminate #ifdef statement. 5 #elif else if used to declare second #ifdef (if first condition check fails). Syntax of Conditionals and examples : #ifdef #ifdef macro_name macro_body #endif #define SUM + #ifdef SUM #include<stdio.h> #endif int main(int argc, char const *argv[]) { int result = 10 SUM 20; printf(\"10 + 20 = %d \\n\", result); return 0; } #undef Used to undefine existing macro #undef macro_name #define SUM + #ifdef SUM #undef SUM #define SUM - #endif int main(int argc, char const *argv[]) { // program will perform subtraction in place of addition. int result = 10 SUM 20; printf(\"10 + 20 = %d\\n\", result); return 0; } #ifndef #ifndef macro_name #ifndef SUM #define SUM + #endif int main(int argc, char const *argv[]) { int result = 10 SUM 20; printf(\"10 + 20 = %d\\n\", result); return 0; } #elif #elif condition elif_body #include<stdio.h> #define NUMBER 12 #if NUMBER > 2 #define SQUARE(x) x * x #elif NUMBER == 2 #define SQUARE(x) 2 * x #else #define SQUARE(x) x #endif int main(int argc, char const *argv[]) { int result = SQUARE(2); printf(\"Square of 2 is %d\\n\",result); return 0; } Examples of Preprocessor Directives : #define CUBE(x) x * x * x #ifndef CUBE #define CUBE(x) x * x * x #endif int main(int argc, char const *argv[]) { int result = CUBE(2); printf(\"Cobe of 3 is %d\\n\", result); return 0; } Program to find max of 6 numbers using macro : #include<stdio.h> #define MAX(a, b) (a) > (b) ? (a) : (b) // Note in above case we used round brackets around a and b // to prevent incorrect substitutuion. int main(int argc, char const *argv[]) { int result = MAX( MAX(MAX(1, 2), MAX(4, 4)), MAX(MAX(5, 6), MAX(7, 8)) ); printf(\"result : %d\\n\",result); return 0; } Pragma preprocessor (IDE Specific) : #pragma startup Before #pragma exit After void Before(){ printf(\"I am before main....\\n\"); } int main(int argc, char const *argv[]) { printf(\"inside main....\\n\"); return 0; } void After(){ printf(\"After main...\\n\"); }","title":"15. More on Preprocessor"},{"location":"c/15-more-on-preprocessor/#conditional-preprocessor","text":"These are used to perform inclusion of file based on some condition.","title":"Conditional Preprocessor :"},{"location":"c/15-more-on-preprocessor/#keywords-related-to-conditional-preprocessor","text":"Sr. keyword Full Form Usage 1 #ifdef if defined used to check whether a macro is declared previously. 2 #ifndef if not defined used to check whether a macro is not declared previously. 3 #undef undefine used to undefine a previous defined macro. 4 #endif end if used to terminate #ifdef statement. 5 #elif else if used to declare second #ifdef (if first condition check fails).","title":"keywords related to conditional preprocessor :"},{"location":"c/15-more-on-preprocessor/#syntax-of-conditionals-and-examples","text":"","title":"Syntax of Conditionals and examples :"},{"location":"c/15-more-on-preprocessor/#ifdef","text":"#ifdef macro_name macro_body #endif #define SUM + #ifdef SUM #include<stdio.h> #endif int main(int argc, char const *argv[]) { int result = 10 SUM 20; printf(\"10 + 20 = %d \\n\", result); return 0; }","title":"#ifdef"},{"location":"c/15-more-on-preprocessor/#undef","text":"Used to undefine existing macro #undef macro_name #define SUM + #ifdef SUM #undef SUM #define SUM - #endif int main(int argc, char const *argv[]) { // program will perform subtraction in place of addition. int result = 10 SUM 20; printf(\"10 + 20 = %d\\n\", result); return 0; }","title":"#undef"},{"location":"c/15-more-on-preprocessor/#ifndef","text":"#ifndef macro_name #ifndef SUM #define SUM + #endif int main(int argc, char const *argv[]) { int result = 10 SUM 20; printf(\"10 + 20 = %d\\n\", result); return 0; }","title":"#ifndef"},{"location":"c/15-more-on-preprocessor/#elif","text":"#elif condition elif_body #include<stdio.h> #define NUMBER 12 #if NUMBER > 2 #define SQUARE(x) x * x #elif NUMBER == 2 #define SQUARE(x) 2 * x #else #define SQUARE(x) x #endif int main(int argc, char const *argv[]) { int result = SQUARE(2); printf(\"Square of 2 is %d\\n\",result); return 0; }","title":"#elif"},{"location":"c/15-more-on-preprocessor/#examples-of-preprocessor-directives","text":"#define CUBE(x) x * x * x #ifndef CUBE #define CUBE(x) x * x * x #endif int main(int argc, char const *argv[]) { int result = CUBE(2); printf(\"Cobe of 3 is %d\\n\", result); return 0; }","title":"Examples of Preprocessor Directives :"},{"location":"c/15-more-on-preprocessor/#program-to-find-max-of-6-numbers-using-macro","text":"#include<stdio.h> #define MAX(a, b) (a) > (b) ? (a) : (b) // Note in above case we used round brackets around a and b // to prevent incorrect substitutuion. int main(int argc, char const *argv[]) { int result = MAX( MAX(MAX(1, 2), MAX(4, 4)), MAX(MAX(5, 6), MAX(7, 8)) ); printf(\"result : %d\\n\",result); return 0; }","title":"Program to find max of 6 numbers using macro :"},{"location":"c/15-more-on-preprocessor/#pragma-preprocessor-ide-specific","text":"#pragma startup Before #pragma exit After void Before(){ printf(\"I am before main....\\n\"); } int main(int argc, char const *argv[]) { printf(\"inside main....\\n\"); return 0; } void After(){ printf(\"After main...\\n\"); }","title":"Pragma preprocessor (IDE Specific) :"},{"location":"c/16-built-in-functions/","text":"Built in Functions C provides us some built in functions to help us, write c programs quickly and easily. Where do these functions exists ? These functions exists in library files provided by c. Header files contain information about function prototype. String related Functions String related functions are used to manipulate strings, calculate length and perform different operations on string. #include<string.h> int main() { char name[50] = \"Jayant Malik\"; // length of string. // navigates till null character and returns the count. printf(\"Length : %d\\n\", strlen(name)); // compare two strings // navigates till last index and returns difference of, // ascii values of characters present, // at index. printf(\"Is Has equals has : %d\\n\", strcmp(\"Has\", \"has\")); printf(\"Is Has equals java : %d\\n\", strcmp(\"Has\", \"java\")); // compare n characters of string. printf(\"Is Jayant compares with Jayant Malik : %d\\n\", strncmp(\"Jayant\", \"Jayant Malik\", 6)) // copy one string to another string. // this function overwrites the string. strcpy(\"Snake Lion\", name); printf(\"Name after copy : %s\\n\", name); // Concatenation of string // this function appends name after string. strcat(name, \"Snake Lion\"); printf(\"Name after concatenation : %s\\n\", name); return 0; } Numbers Related Functions : #include<math.h> int main() { int number = 20; // math related functions printf(\"Sin %d : %f\\n\", number, sin(number)); printf(\"Cos %d : %f\\n\", number, cos(number)); printf(\"Tan %d : %f\\n\", number, tan(number)); printf(\"Cosec %d : %f\\n\", number, 1 / sin(number)); printf(\"Sec %d : %f\\n\", number, 1 / cos(number)); printf(\"Cot %d : %f\\n\", number, 1 / tan(number)); // Modulus of floating point numbers. // on linux use : gcc filename -lm // to link libm library that contains // math decimal point related functions. printf(\"20.5 % 3.6 = %f\\n\", fmod(20.5, 3.6)); return 0; } Quick prototype of string related functions : char *strcpy (char *dest, char *src); //Copy src string into dest string. char *strncpy(char *string1, char *string2, int n); //Copy first n characters of string2 to stringl . int strcmp(char *string1, char *string2); //Compare string1 and string2 to determine alphabetic order. int strncmp(char *string1, char *string2, int n); //Compare first n characters of two strings. int strlen(char *string); //Determine the length of a string. char *strcat(char *dest, const char *src); //Concatenate string src to the string dest. char *strncat(char *dest, const char *src, int n); //Concatenate n chracters from string src to the string dest. char *strchr(char *string, int c); //Find first occurrence of character c in string. char *strrchr(char *string, int c); //Find last occurrence of character c in string. char *strstr(char *string2, char string*1); //Find first occurrence of string string1 in string2. char *strtok(char *s, const char *delim) ; //Parse the string s into tokens using delim as delimiter. Quick prototype of memory related functions : void *calloc(int num elems, int elem_size); //Allocate an array and initialise all elements to zero . void free(void *mem address); //Free a block of memory. void *malloc(int num bytes); //Allocate a block of memory. void *realloc(void *mem address, int newsize); //Reallocate (adjust size) a block of memory. Quick prototype of buffer related functions : void* memcpy(void* s, const void* ct, int n); //Copies n characters from ct to s and returns s. s may be corrupted if objects overlap. int memcmp(const void* cs, const void* ct, int n); //Compares at most (the first) n characters of cs and ct, returning negative value if cs<ct, zero if cs==ct, positive value if cs>ct. void* memchr(const void* cs, int c, int n); //Returns pointer to first occurrence of c in first n characters of cs, or NULL if not found. void* memset(void* s, int c, int n); //Replaces each of the first n characters of s by c and returns s. void* memmove(void* s, const void* ct, int n); //Copies n characters from ct to s and returns s. s will not be corrupted if objects overlap. Quick prototype of character related functions : int isalnum(int c); //The function returns nonzero if c is alphanumeric int isalpha(int c); //The function returns nonzero if c is alphabetic only int iscntrl(int c); //The function returns nonzero if c is a control chracter int isdigit(int c); //The function returns nonzero if c is a numeric digit int isgraph(int c); //The function returns nonzero if c is any character for which either isalnum or ispunct returns nonzero. int islower(int c); //The function returns nonzero if c is a lower case character. int isprint(int c); //The function returns nonzero if c is space or a character for which isgraph returns nonzero. int ispunct(int c); //The function returns nonzero if c is punctuation int isspace(int c); //The function returns nonzero if c is space character int isupper(int c); //The function returns nonzero if c is upper case character int isxdigit(int c); //The function returns nonzero if c is hexa digit int tolower(int c); //The function returns the corresponding lowercase letter if one exists and if isupper(c); otherwise, it returns c. int toupper(int c); //The function returns the corresponding uppercase letter if one exists and if islower(c); otherwise, it returns c. Quick prototype of character related functions : void perror(const char *s); //produces a message on standard error output describing the last error encountered. char *strerror(int errnum ); //returns a string describing the error code passed in the argument errnum.","title":"16. Built in Functions"},{"location":"c/16-built-in-functions/#built-in-functions","text":"C provides us some built in functions to help us, write c programs quickly and easily.","title":"Built in Functions"},{"location":"c/16-built-in-functions/#where-do-these-functions-exists","text":"These functions exists in library files provided by c. Header files contain information about function prototype.","title":"Where do these functions exists ?"},{"location":"c/16-built-in-functions/#string-related-functions","text":"String related functions are used to manipulate strings, calculate length and perform different operations on string. #include<string.h> int main() { char name[50] = \"Jayant Malik\"; // length of string. // navigates till null character and returns the count. printf(\"Length : %d\\n\", strlen(name)); // compare two strings // navigates till last index and returns difference of, // ascii values of characters present, // at index. printf(\"Is Has equals has : %d\\n\", strcmp(\"Has\", \"has\")); printf(\"Is Has equals java : %d\\n\", strcmp(\"Has\", \"java\")); // compare n characters of string. printf(\"Is Jayant compares with Jayant Malik : %d\\n\", strncmp(\"Jayant\", \"Jayant Malik\", 6)) // copy one string to another string. // this function overwrites the string. strcpy(\"Snake Lion\", name); printf(\"Name after copy : %s\\n\", name); // Concatenation of string // this function appends name after string. strcat(name, \"Snake Lion\"); printf(\"Name after concatenation : %s\\n\", name); return 0; }","title":"String related Functions"},{"location":"c/16-built-in-functions/#numbers-related-functions","text":"#include<math.h> int main() { int number = 20; // math related functions printf(\"Sin %d : %f\\n\", number, sin(number)); printf(\"Cos %d : %f\\n\", number, cos(number)); printf(\"Tan %d : %f\\n\", number, tan(number)); printf(\"Cosec %d : %f\\n\", number, 1 / sin(number)); printf(\"Sec %d : %f\\n\", number, 1 / cos(number)); printf(\"Cot %d : %f\\n\", number, 1 / tan(number)); // Modulus of floating point numbers. // on linux use : gcc filename -lm // to link libm library that contains // math decimal point related functions. printf(\"20.5 % 3.6 = %f\\n\", fmod(20.5, 3.6)); return 0; }","title":"Numbers Related Functions :"},{"location":"c/16-built-in-functions/#quick-prototype-of-string-related-functions","text":"char *strcpy (char *dest, char *src); //Copy src string into dest string. char *strncpy(char *string1, char *string2, int n); //Copy first n characters of string2 to stringl . int strcmp(char *string1, char *string2); //Compare string1 and string2 to determine alphabetic order. int strncmp(char *string1, char *string2, int n); //Compare first n characters of two strings. int strlen(char *string); //Determine the length of a string. char *strcat(char *dest, const char *src); //Concatenate string src to the string dest. char *strncat(char *dest, const char *src, int n); //Concatenate n chracters from string src to the string dest. char *strchr(char *string, int c); //Find first occurrence of character c in string. char *strrchr(char *string, int c); //Find last occurrence of character c in string. char *strstr(char *string2, char string*1); //Find first occurrence of string string1 in string2. char *strtok(char *s, const char *delim) ; //Parse the string s into tokens using delim as delimiter.","title":"Quick prototype of string related functions :"},{"location":"c/16-built-in-functions/#quick-prototype-of-memory-related-functions","text":"void *calloc(int num elems, int elem_size); //Allocate an array and initialise all elements to zero . void free(void *mem address); //Free a block of memory. void *malloc(int num bytes); //Allocate a block of memory. void *realloc(void *mem address, int newsize); //Reallocate (adjust size) a block of memory.","title":"Quick prototype of memory related functions :"},{"location":"c/16-built-in-functions/#quick-prototype-of-buffer-related-functions","text":"void* memcpy(void* s, const void* ct, int n); //Copies n characters from ct to s and returns s. s may be corrupted if objects overlap. int memcmp(const void* cs, const void* ct, int n); //Compares at most (the first) n characters of cs and ct, returning negative value if cs<ct, zero if cs==ct, positive value if cs>ct. void* memchr(const void* cs, int c, int n); //Returns pointer to first occurrence of c in first n characters of cs, or NULL if not found. void* memset(void* s, int c, int n); //Replaces each of the first n characters of s by c and returns s. void* memmove(void* s, const void* ct, int n); //Copies n characters from ct to s and returns s. s will not be corrupted if objects overlap.","title":"Quick prototype of buffer related functions :"},{"location":"c/16-built-in-functions/#quick-prototype-of-character-related-functions","text":"int isalnum(int c); //The function returns nonzero if c is alphanumeric int isalpha(int c); //The function returns nonzero if c is alphabetic only int iscntrl(int c); //The function returns nonzero if c is a control chracter int isdigit(int c); //The function returns nonzero if c is a numeric digit int isgraph(int c); //The function returns nonzero if c is any character for which either isalnum or ispunct returns nonzero. int islower(int c); //The function returns nonzero if c is a lower case character. int isprint(int c); //The function returns nonzero if c is space or a character for which isgraph returns nonzero. int ispunct(int c); //The function returns nonzero if c is punctuation int isspace(int c); //The function returns nonzero if c is space character int isupper(int c); //The function returns nonzero if c is upper case character int isxdigit(int c); //The function returns nonzero if c is hexa digit int tolower(int c); //The function returns the corresponding lowercase letter if one exists and if isupper(c); otherwise, it returns c. int toupper(int c); //The function returns the corresponding uppercase letter if one exists and if islower(c); otherwise, it returns c.","title":"Quick prototype of character related functions :"},{"location":"c/16-built-in-functions/#quick-prototype-of-character-related-functions_1","text":"void perror(const char *s); //produces a message on standard error output describing the last error encountered. char *strerror(int errnum ); //returns a string describing the error code passed in the argument errnum.","title":"Quick prototype of character related functions :"},{"location":"c/17-reference-guide/","text":"Basic Input and output Functions (stdio.h) : Function Description fopen(name, \u201cr\u201d) opens file name for read, returns FILE *f; \u201cw\u201d allows write fclose(f) closes file f getchar() read 1 char from stdin or pushback; is EOF (int -1) if none ungetch(c) pushback char c into stdin for re-reading; don\u2019t change c putchar(c) write 1 char, c, to stdout fgetc(f) same as getchar(), but reads from file f ungetc(c,f) same as ungetchar() but onto file f fputc(c,f) same as putchar(c), but onto file f fgets(s,n, f) read string of n-1 chars to a s from f or til eof or \\n fputs(s,f) writes string s to f: e.g. fputs(\u201cHello world\\n\u201d, stdout); scanf(p,...) reads ... args using format p (below); put &w/non-pointers printf(p, ...) write ... args using format p (below); pass args as is fprintf(f,p,...) same, but print to file f fscanf(f,p,...) same, but read from file f sscanf(s,p,...) same, but read from string s sprintf(s,p,...) same, as printf, but to string s feof(f) return true iff at end of file f Memory management Functions (stdlib.h): Function Description malloc(n) alloc n bytes of memory; for type T: p = (T*)malloc(sizeof(t)); free(p) free memory pointed at p; must have been alloc\u2019d; don\u2019t re-free calloc(n,s) alloc n-array size s & clear; typ: a = (T*)calloc(n, sizeof(T)); Math Related Functions (math.h) (link -lm) : All functions take and return double unless otherwise noted: Function Description sin(a), cos(a), tan(a) sine, cosine, tangent of double (in radians) asine(y),acos(x),atan(r) principle inverse of above atan2(y,x) principal inverse of tan(y/x) in same quadrant as (x,y) sqrt(x) root of x log(x) natural logarithm of x; others: log2(x) and log10(x) exp(p) e to the power of p; others: exp2(x) and exp10(x) pow(x,y) x to the power of y; like (expy*log(x)) ceil(x) smallest integer (returned as double) no less than x floor(x) largest integer (returned as double) no greater than y abs(x) absolute value of x random() returns a random long srandom(seed) seeds the random generator with a new random seed String related functions (string.h) : Function Description strlen(s) return length of string; number of characters before ASCII 0 strcpy(d,s) copy string s to d and return d; N.B. parameter order like = strncpy(d,s,n) copy at most n characters of s to d and terminate; returns d stpcpy(d,s) like strcpy, but returns pointer to ASCII 0 terminator in d strcmp(s,t) compare strings s and t and return first difference; 0=> equal strncmp(s,t,n) stop after at most n characters; needn\u2019t be null terminated memcpy(d,s,n) copy exactly n bytes from s to d; may fail if s overlaps d memmove(d,s,n) (slow) copy n bytes from s to d; won\u2019t fail if s overlaps d","title":"17. Reference Guide"},{"location":"c/17-reference-guide/#basic-input-and-output-functions-stdioh","text":"Function Description fopen(name, \u201cr\u201d) opens file name for read, returns FILE *f; \u201cw\u201d allows write fclose(f) closes file f getchar() read 1 char from stdin or pushback; is EOF (int -1) if none ungetch(c) pushback char c into stdin for re-reading; don\u2019t change c putchar(c) write 1 char, c, to stdout fgetc(f) same as getchar(), but reads from file f ungetc(c,f) same as ungetchar() but onto file f fputc(c,f) same as putchar(c), but onto file f fgets(s,n, f) read string of n-1 chars to a s from f or til eof or \\n fputs(s,f) writes string s to f: e.g. fputs(\u201cHello world\\n\u201d, stdout); scanf(p,...) reads ... args using format p (below); put &w/non-pointers printf(p, ...) write ... args using format p (below); pass args as is fprintf(f,p,...) same, but print to file f fscanf(f,p,...) same, but read from file f sscanf(s,p,...) same, but read from string s sprintf(s,p,...) same, as printf, but to string s feof(f) return true iff at end of file f","title":"Basic Input and output Functions (stdio.h) :"},{"location":"c/17-reference-guide/#memory-management-functions-stdlibh","text":"Function Description malloc(n) alloc n bytes of memory; for type T: p = (T*)malloc(sizeof(t)); free(p) free memory pointed at p; must have been alloc\u2019d; don\u2019t re-free calloc(n,s) alloc n-array size s & clear; typ: a = (T*)calloc(n, sizeof(T));","title":"Memory management Functions (stdlib.h):"},{"location":"c/17-reference-guide/#math-related-functions-mathh-link-lm","text":"All functions take and return double unless otherwise noted: Function Description sin(a), cos(a), tan(a) sine, cosine, tangent of double (in radians) asine(y),acos(x),atan(r) principle inverse of above atan2(y,x) principal inverse of tan(y/x) in same quadrant as (x,y) sqrt(x) root of x log(x) natural logarithm of x; others: log2(x) and log10(x) exp(p) e to the power of p; others: exp2(x) and exp10(x) pow(x,y) x to the power of y; like (expy*log(x)) ceil(x) smallest integer (returned as double) no less than x floor(x) largest integer (returned as double) no greater than y abs(x) absolute value of x random() returns a random long srandom(seed) seeds the random generator with a new random seed","title":"Math Related Functions (math.h) (link -lm) :"},{"location":"c/17-reference-guide/#string-related-functions-stringh","text":"Function Description strlen(s) return length of string; number of characters before ASCII 0 strcpy(d,s) copy string s to d and return d; N.B. parameter order like = strncpy(d,s,n) copy at most n characters of s to d and terminate; returns d stpcpy(d,s) like strcpy, but returns pointer to ASCII 0 terminator in d strcmp(s,t) compare strings s and t and return first difference; 0=> equal strncmp(s,t,n) stop after at most n characters; needn\u2019t be null terminated memcpy(d,s,n) copy exactly n bytes from s to d; may fail if s overlaps d memmove(d,s,n) (slow) copy n bytes from s to d; won\u2019t fail if s overlaps d","title":"String related functions (string.h) :"},{"location":"c/18-functions-with-pointers/","text":"Functions with pointers : Functions with pointers are also known as call by reference functions. Points : These functions could contain pointers as formal argument. These could return a pointer as a value from function. Functions Returning pointers as a value : Make sure the address value of variable exists after pop of function from stack, else the output is not guaranteed correct because that memory location could be overwritten by some other program or by your own program. Syntax : return_type * function_name(arguments) { // body of function return address_variable; } Example : char *copy(char *destination, char * source){ int index = 0; while(*(source + index) != '\\0'){ *(destination + index) = *(source + index); index++; } int main(){ char *name1 = \"Jayant Malik\"; printf(\"Before Copy : %s\\n\", name1); copy(name1, \"Sam Novak\"); printf(\"After Copy : %s\\n\", name1); printf(\"After Copy, printing using return value from function : %s\\n\", copy(name1, \"Apples are sweet\")); return 0; }","title":"18. Functions with Pointers"},{"location":"c/18-functions-with-pointers/#functions-with-pointers","text":"Functions with pointers are also known as call by reference functions.","title":"Functions with pointers :"},{"location":"c/18-functions-with-pointers/#points","text":"These functions could contain pointers as formal argument. These could return a pointer as a value from function.","title":"Points :"},{"location":"c/18-functions-with-pointers/#functions-returning-pointers-as-a-value","text":"Make sure the address value of variable exists after pop of function from stack, else the output is not guaranteed correct because that memory location could be overwritten by some other program or by your own program.","title":"Functions Returning pointers as a value :"},{"location":"c/18-functions-with-pointers/#syntax","text":"return_type * function_name(arguments) { // body of function return address_variable; }","title":"Syntax :"},{"location":"c/18-functions-with-pointers/#example","text":"char *copy(char *destination, char * source){ int index = 0; while(*(source + index) != '\\0'){ *(destination + index) = *(source + index); index++; } int main(){ char *name1 = \"Jayant Malik\"; printf(\"Before Copy : %s\\n\", name1); copy(name1, \"Sam Novak\"); printf(\"After Copy : %s\\n\", name1); printf(\"After Copy, printing using return value from function : %s\\n\", copy(name1, \"Apples are sweet\")); return 0; }","title":"Example :"},{"location":"c/19-built-in-char-functions/","text":"Working On Built In Functions : we will discuss built in functions in c and how to create them yourself. Character Handling Steps : Create a program to list ascii values of all characters and not them down in table. Now use concept of ascii values to distinguish between different characters Program to print ascii values of characters : int main(){ for(int i = 0; i <= 255; i++){ printf(\"%d | %c, \", i, i); } return 0; } Observation table : Character Type Ascii Value a - z 97 - 122 A - z 65 - 90 0 - 9 48 - 57 space 32 control 0 - 31 punctuation 33 - 47, 58 - 64, 91 - 96, 123 -126 Program to check whether a character is lower case int islower(const unsigned int character){ if(character >= 92 && character <= 122) return 1; else return 0; } int main(int argc, char const *argv[]) { int result = islower('a'); printf(\"Character a is lower or upper : %d\\n\",result); return 0; } Program to check whether a character is alphabet. int isalpha(const unsigned int character){ if(character >= 92 && character <= 122) return 1; else if(character >= 65 && character <= 90) return 1; else return 0; } int main(int argc, char const *argv[]) { int result = isalpha('a'); printf(\"Character a is alphabet or not : %d\\n\",result); return 0; } Program to check whether a character is upper case int isupper(const unsigned int character){ return (character >= 65 && character <= 90) ? 1 : 0; } int main(int argc, char const *argv[]) { int result = isupper('A'); printf(\"Character a is uppercase or not: %d\\n\",result); return 0; } Program to check whether a character is punctuation character. int ispunct(const unsigned int character){ if( (character >= 33 && character <= 47) || (character >= 58 && character <= 64) || (character >= 91 && character <= 96) || (character >= 123 && character <= 126) ) { return 1; } return 0; } int main(int argc, char const *argv[]) { int result = ispunct('!'); printf(\"Character a is punctuation or not: %d\\n\",result); return 0; } Program to check whether a character is control character. int iscntrl(const unsigned int character){ return (character >= 0 && character <= 31) ? 1 : 0; } int main(int argc, char const *argv[]) { int result = iscntrl('\\0'); printf(\"Character \\\\0 is control character or not: %d\\n\",result); return 0; } Program to convert lower case character to upper case. char toupper(const unsigned int character){ if(character >= 97 && character <= 122) return character - 32; else if(character >=65 && character <= 90) return character; else return '\\0'; } int main(int argc, char const *argv[]) { char result = toupper('a'); printf(\"Character a in upper case is : %c\\n\",result); return 0; } Program to convert character to lower case char tolower(const unsigned int character){ if(character >= 97 && character <= 122) return character; else if(character >=65 && character <= 90) return character + 32; else return '\\0'; } int main(int argc, char const *argv[]) { char result = tolower('A'); printf(\"A in lower case is %c\\n\",result); return 0; } Now we created saveral functions and learnt how they are made ? Now, Let's compare our functions with built in functions. Some reasons behind all these functions : All functions take int as their formal argument because every character is a binary number that can be converted to any format as per requirement. All functions except toupper and tolower returns 0 for false and 1 for true as result. We used unsigned int in formal type of each function to prevent cyclic behaviour to some extent. Creating header file for our code : #define __THROW '\\0'; #define __INVALID 0; char cdecl toupper(const unsigned int __letter) __THROW; char cdecl tolower(const unsigned int __letter) __THROW; int cdecl isalpha(const unsigned int __letter) __INVALID; int cdecl iscntrl(const unsigned int __letter) __INVALID; int cdecl islower(const unsigned int __letter) __INVALID; int cdecl isupper(const unsigned int __letter) __INVALID; int cdecl ispunct(const unsigned int __letter) __INVALID; Generating .dll and header files To generate dll files we need to create .obj files from our code. Code should be written without main function to generate .obj file You can use some IDE to generate .dll project for you(optional) Program file with all code without main becomes : char tolower(const unsigned int character){ if(character >= 97 && character <= 122) return character; else if(character >=65 && character <= 90) return character + 32; else return '\\0'; } char toupper(const unsigned int character){ if(character >= 97 && character <= 122) return character - 32; else if(character >=65 && character <= 90) return character; else return '\\0'; } int iscntrl(const unsigned int character){ return (character >= 0 && character <= 31) ? 1 : 0; } int ispunct(const unsigned int character){ if( (character >= 33 && character <= 47) || (character >= 58 && character <= 64) || (character >= 91 && character <= 96) || (character >= 123 && character <= 126) ) { return 1; } return 0; } int isupper(const unsigned int character){ return (character >= 65 && character <= 90) ? 1 : 0; } int isalpha(const unsigned int character){ if(character >= 92 && character <= 122) return 1; else if(character >= 65 && character <= 90) return 1; else return 0; } int islower(const unsigned int character){ if(character >= 92 && character <= 122) return 1; else return 0; } Now Command for gcc to generate .obj file Checking for errors gcc -o output_file input_file you got an error right, this is because you cannot submit built in functions with same name as yours. to solve this issue just change name of your function tolower() ---> tolowercase() and toupper() ---> touppercase() Generating object file gcc -c input_file generating dll gcc -shared -o output.dll input_file.o Now you can copy header file created with .h file to /usr/include/file_name.h Testing everything : 1. create a file.c int main(){ int result = isupper('a'); printf(\"Character in upper case is %d\\n\",result); return 0; } 2. Compile and generate executable gcc -o test input_file.c -L file_name.dll 3. Run program ./test","title":"19. Built in Char Functions"},{"location":"c/19-built-in-char-functions/#working-on-built-in-functions","text":"we will discuss built in functions in c and how to create them yourself.","title":"Working On Built In Functions :"},{"location":"c/19-built-in-char-functions/#character-handling","text":"","title":"Character Handling "},{"location":"c/19-built-in-char-functions/#steps","text":"Create a program to list ascii values of all characters and not them down in table. Now use concept of ascii values to distinguish between different characters","title":"Steps :"},{"location":"c/19-built-in-char-functions/#program-to-print-ascii-values-of-characters","text":"int main(){ for(int i = 0; i <= 255; i++){ printf(\"%d | %c, \", i, i); } return 0; }","title":"Program to print ascii values of characters :"},{"location":"c/19-built-in-char-functions/#observation-table","text":"Character Type Ascii Value a - z 97 - 122 A - z 65 - 90 0 - 9 48 - 57 space 32 control 0 - 31 punctuation 33 - 47, 58 - 64, 91 - 96, 123 -126","title":"Observation table :"},{"location":"c/19-built-in-char-functions/#program-to-check-whether-a-character-is-lower-case","text":"int islower(const unsigned int character){ if(character >= 92 && character <= 122) return 1; else return 0; } int main(int argc, char const *argv[]) { int result = islower('a'); printf(\"Character a is lower or upper : %d\\n\",result); return 0; }","title":"Program to check whether a character is lower case"},{"location":"c/19-built-in-char-functions/#program-to-check-whether-a-character-is-alphabet","text":"int isalpha(const unsigned int character){ if(character >= 92 && character <= 122) return 1; else if(character >= 65 && character <= 90) return 1; else return 0; } int main(int argc, char const *argv[]) { int result = isalpha('a'); printf(\"Character a is alphabet or not : %d\\n\",result); return 0; }","title":"Program to check whether a character is alphabet."},{"location":"c/19-built-in-char-functions/#program-to-check-whether-a-character-is-upper-case","text":"int isupper(const unsigned int character){ return (character >= 65 && character <= 90) ? 1 : 0; } int main(int argc, char const *argv[]) { int result = isupper('A'); printf(\"Character a is uppercase or not: %d\\n\",result); return 0; }","title":"Program to check whether a character is upper case"},{"location":"c/19-built-in-char-functions/#program-to-check-whether-a-character-is-punctuation-character","text":"int ispunct(const unsigned int character){ if( (character >= 33 && character <= 47) || (character >= 58 && character <= 64) || (character >= 91 && character <= 96) || (character >= 123 && character <= 126) ) { return 1; } return 0; } int main(int argc, char const *argv[]) { int result = ispunct('!'); printf(\"Character a is punctuation or not: %d\\n\",result); return 0; }","title":"Program to check whether a character is punctuation character."},{"location":"c/19-built-in-char-functions/#program-to-check-whether-a-character-is-control-character","text":"int iscntrl(const unsigned int character){ return (character >= 0 && character <= 31) ? 1 : 0; } int main(int argc, char const *argv[]) { int result = iscntrl('\\0'); printf(\"Character \\\\0 is control character or not: %d\\n\",result); return 0; }","title":"Program to check whether a character is control character."},{"location":"c/19-built-in-char-functions/#program-to-convert-lower-case-character-to-upper-case","text":"char toupper(const unsigned int character){ if(character >= 97 && character <= 122) return character - 32; else if(character >=65 && character <= 90) return character; else return '\\0'; } int main(int argc, char const *argv[]) { char result = toupper('a'); printf(\"Character a in upper case is : %c\\n\",result); return 0; }","title":"Program to convert lower case character to upper case."},{"location":"c/19-built-in-char-functions/#program-to-convert-character-to-lower-case","text":"char tolower(const unsigned int character){ if(character >= 97 && character <= 122) return character; else if(character >=65 && character <= 90) return character + 32; else return '\\0'; } int main(int argc, char const *argv[]) { char result = tolower('A'); printf(\"A in lower case is %c\\n\",result); return 0; }","title":"Program to convert character to lower case"},{"location":"c/19-built-in-char-functions/#now-we-created-saveral-functions-and-learnt-how-they-are-made-now-lets-compare-our-functions-with-built-in-functions","text":"","title":"Now we created saveral functions and learnt how they are made ? Now, Let's compare our functions with built in functions."},{"location":"c/19-built-in-char-functions/#some-reasons-behind-all-these-functions","text":"All functions take int as their formal argument because every character is a binary number that can be converted to any format as per requirement. All functions except toupper and tolower returns 0 for false and 1 for true as result. We used unsigned int in formal type of each function to prevent cyclic behaviour to some extent.","title":"Some reasons behind all these functions :"},{"location":"c/19-built-in-char-functions/#creating-header-file-for-our-code","text":"#define __THROW '\\0'; #define __INVALID 0; char cdecl toupper(const unsigned int __letter) __THROW; char cdecl tolower(const unsigned int __letter) __THROW; int cdecl isalpha(const unsigned int __letter) __INVALID; int cdecl iscntrl(const unsigned int __letter) __INVALID; int cdecl islower(const unsigned int __letter) __INVALID; int cdecl isupper(const unsigned int __letter) __INVALID; int cdecl ispunct(const unsigned int __letter) __INVALID;","title":"Creating header file for our code :"},{"location":"c/19-built-in-char-functions/#generating-dll-and-header-files","text":"To generate dll files we need to create .obj files from our code. Code should be written without main function to generate .obj file You can use some IDE to generate .dll project for you(optional)","title":"Generating .dll and header files"},{"location":"c/19-built-in-char-functions/#program-file-with-all-code-without-main-becomes","text":"char tolower(const unsigned int character){ if(character >= 97 && character <= 122) return character; else if(character >=65 && character <= 90) return character + 32; else return '\\0'; } char toupper(const unsigned int character){ if(character >= 97 && character <= 122) return character - 32; else if(character >=65 && character <= 90) return character; else return '\\0'; } int iscntrl(const unsigned int character){ return (character >= 0 && character <= 31) ? 1 : 0; } int ispunct(const unsigned int character){ if( (character >= 33 && character <= 47) || (character >= 58 && character <= 64) || (character >= 91 && character <= 96) || (character >= 123 && character <= 126) ) { return 1; } return 0; } int isupper(const unsigned int character){ return (character >= 65 && character <= 90) ? 1 : 0; } int isalpha(const unsigned int character){ if(character >= 92 && character <= 122) return 1; else if(character >= 65 && character <= 90) return 1; else return 0; } int islower(const unsigned int character){ if(character >= 92 && character <= 122) return 1; else return 0; }","title":"Program file with all code without main becomes :"},{"location":"c/19-built-in-char-functions/#now-command-for-gcc-to-generate-obj-file","text":"","title":"Now Command for gcc to generate .obj file"},{"location":"c/19-built-in-char-functions/#checking-for-errors","text":"gcc -o output_file input_file you got an error right, this is because you cannot submit built in functions with same name as yours. to solve this issue just change name of your function tolower() ---> tolowercase() and toupper() ---> touppercase()","title":"Checking for errors"},{"location":"c/19-built-in-char-functions/#generating-object-file","text":"gcc -c input_file","title":"Generating object file"},{"location":"c/19-built-in-char-functions/#generating-dll","text":"gcc -shared -o output.dll input_file.o","title":"generating dll"},{"location":"c/19-built-in-char-functions/#now-you-can-copy-header-file-created-with-h-file-to-usrincludefile_nameh","text":"","title":"Now you can copy header file created with .h file to /usr/include/file_name.h"},{"location":"c/19-built-in-char-functions/#testing-everything","text":"1. create a file.c int main(){ int result = isupper('a'); printf(\"Character in upper case is %d\\n\",result); return 0; } 2. Compile and generate executable gcc -o test input_file.c -L file_name.dll 3. Run program ./test","title":"Testing everything :"},{"location":"c/20-structures/","text":"Structures in C : structures are user defined datatype used for storing entities of data. Entity is any real world physical thing. Why we need structures ? In order to store data in a single unit form. To create our own user defined datatype. To create memory location for different datatype in sequential order. To store details of some object. Example : storing id name and age of a student. Where structure could be useful ? Let's say we need to store student name and age, then c program for it could be like this without structure : int main(){ char name[20]; int age; printf(\"Enter student name :\\t\"); scanf(\"%s\",name); // remember array name itself holds memory address of base location or address of zero index element. printf(\"Enter student age :\\t\"); scanf(\"%d\",&age); printf(\"%s has age of %d\",name,age); return 0; } In order to keep details of student in such manner, c does not guarantee us that name and age variable will be in sequential order. Real Life usage of Structures : 1. In order to create a metro ticketing system, developers needed a tool to store data about issuer, client, price, from, to, and so many other details. So, they used structures to implement the same. 2. facebook uses structures to store data of person, posts, comments.... 3. Telecom company uses structures to store data... How does a structure looks : struct Rect{ double breadth; double length; } typedef struct Rect Rect; int main(){ Rect x; x.length = 100; x.breadth = 200; printf(\"Rect has length %ld and breadth %ld\\n\", x.length, x.breadth ); return 0; } Syntax of Structure Definition : struct structure_name{ datatype value1; datatype value2; datatype value3; }; // Example struct Rectangle{ double length; double breadth; }; Syntax of Structure with variables inside code : int main(){ struct structure_name variable_name; //Example struct Rectangle rect1; return 0; } Accessing Elements of Structure : int main(){ struct Rectangle rect1; printf(\"Length = %ld\\n\",rect1.length); printf(\"Breadth = %d\\n\",rect1.breadth); return 0; } Rules for structures : Naming of structure is same as variable name. Structure definition starts with struct reserved keyword of c. Structure definition ends with a semicolon. Structure could contain different datatypes. Structures are accessed using direct member accessor operator (.) or period. Structures are could also be accessed using indirect member accesor operator ( -> ) Variables inside body of structure are allocated sequential poitions. Function declaration is not allowed inside structures. Structures are used to create variables of own defined type with a specific syntax (struct struct_name variable_name ); Variables in body of structure cannot be assigned direct values. By default all elements of structure gets garbage value. Structure name is mapped to first element in struct. Example of struct struct Rect{ double length; double breadth; }; int main(){ struct Rect rect1; // garbage value proof. printf(\"Length : %ld and Breadth : %ld\\n\",rect1.length, rect1.breadth); // set custom values to rect1 rect1.length = 100; rect1.breadth = 200; printf(\"Length : %ld and Breadth : %ld\\n\",rect1.length, rect1.breadth); return 0; } Direct Member accessor operator / Direct Component selector operator: period or dot is called as direct member accessor operator. It is a binary operators means, requires two inputs : first input : variable_name second input : property name or struct member name. Memory Formation of Structure : example : struct Sample{ char grade; char blood_group; }; Memory: [][][][][][][][] [][][][][][][][][] Variable grade blood_group Address 520620 520621 Size 1 byte 1 byte Total size of structure depends on datatypes used inside body of struct. Preventing use of struct every time we create a variable : struct Rect{ double length; double bredth; }; typedef struct Rect Rect; int main(int argc, char const *argv[]) { Rect rect1; rect1.length = 10; rect2.breadth = 20; printf(\"length : %ld, breadth : %ld\\n\",rect1.length, rect2.length); return 0; } Another syntax of using typedef : //direct use of typedef to create struct. typedef struct{ double length; double breadth; } Rect; int main(){ Rect rect1; // some related code. return 0; } Using Functions to Print Elements of structure : struct Rect{ int length; int breadth; }; typedef struct Rect Rect; void display(Rect rect){ printf(\"length : %d, breadth : %d\\n\", rect.length, rect.breadth); } int main(int argc, char const *argv[]) { Rect rect1; Rect rect2 = {100, 200}; rect1.length = 20; rect1.breadth = 30; // code consumes high memory due to clone formation in stack. display(rect1); display(rect2); return 0; } Advantages of use with pointers : Less memory space is required by application. Cloning of struct datatype is prevented. Variables in local scope could be manipulated. Reduces number of operations in STACK formation. Pointers with struct : typedef struct{ int length; int breadth; } Rect; int main(int argc, char const *argv[]) { Rect rect1; Rect *ptr; ptr = &rect1; ptr->length = 100; ptr->breadth = 200; printf(\"Length : %d and Breadth : %d\\n\",rect1.length, rect1.breadth); return 0; } Indirect Member Access Operator/ Indirect Component Selector Operator ( -> ): It is a binary operator, hence takes two inputs first : address of variable second : member of struct. Difference in size of pointers and struct : typedef struct{ int length; int breadth; } Rect; int main(int argc, char const *argv[]) { Rect rect1; Rect *ptr; printf(\"Size of rect1 is %lu bytes\\n\", sizeof(rect1)); printf(\"Size of ptr is %lu bytes\\n\", sizeof(ptr)); return 0; } Passing pointers to functions typedef struct{ int length; int breadth; } Rect; void print_data(Rect * ptr){ printf(\"length : %d, breadth : %d\\n\",(*ptr).length, ptr -> breadth); } int main(int argc, char const *argv[]) { Rect rect1 = {10, 20}; print_data(&rect1); return 0; } program to get data from user and store in variable : typedef struct{ int length; int breadth; } Rect; void get_data(Rect *rect){ printf(\"Enter length :\\t\"); scanf(\"%d\",&rect->length); printf(\"Enter breadth:\\t\"); scanf(\"%d\",&rect->breadth); } void print_data(Rect *rect){ printf(\"length : %d, breadth : %d\\n\",(*rect).length, rect->breadth); } int main(int argc, char const *argv[]) { Rect rect1; Rect rect2; get_data(&rect1); get_data(&rect2); print_data(&rect1); print_data(&rect2); return 0; } Return data from user defined function : // write a program in c to compare two rectangles. struct Rect{ int length; int breadth; }; typedef struct Rect Rect; Rect * compare(Rect const *rect1, Rect const *rect2){ int area1 = rect1->length * rect1->breadth; int area2 = rect2->length * rect2->breadth; return (area1 > area2) ? rect1 : rect2; } int main(int argc, char const *argv[]) { Rect rect1 = {100, 200}; Rect rect2 = {200, 400}; Rect const * result = compare(&rect1, &rect2); printf(\"length : %d, breadth : %d\\n\",result->length, result->breadth); return 0; } Write a program in c to add two rectangles : struct Rect{ int length; int breadth; }; typedef struct Rect Rect; Rect add_rectangle(const Rect *rect1, Rect const *rect2){ Rect temp; temp.length = rect1 -> length + rect2 -> length; temp.breadth = rect1 -> breadth + rect2 -> breadth; return temp; } int main(int argc, char const *argv[]) { Rect rect1 = {10, 20}; Rect rect2 = {50, 60}; Rect resultant = add_rectangle(&rect1, &rect2); printf(\"Resultant Rectangle, length : %d and breadth : %d\\n\", resultant.length, resultant.breadth); return 0; } Write a program in c to store data of 10 employees. #include<stdio_ext.h> #define NUMBER_OF_CLIENTS 10 // could create seperate header file for this info. struct Employee{ char name[20]; int age; int salary; }; typedef struct Employee Employee; void getClientData(Employee *client){ printf(\"Enter employee name :\\t\"); scanf(\"%s\",&client->name); __fpurge(stdin); printf(\"Enter employee age :\\t\"); scanf(\"%d\",&client->age); __fpurge(stdin); printf(\"Enter employee salary :\\t\"); scanf(\"%d\",&client->salary); __fpurge(stdin); } int main(int argc, char const *argv[]) { Employee client[NUMBER_OF_CLIENTS] = {\"\", 0, 0}; int index = 0; while(1){ printf(\"Enter y to add record and q to quit..\\t\"); char ch = getchar(); if(ch == 'q') break; getClientData(&client[index]); index++; } for(int i = 0; i <2; i++){ printf(\"%s, %d, %d\\n\",client[i].name, client[i].age, client[i].salary); } return 0; }","title":"20. Structures"},{"location":"c/20-structures/#structures-in-c","text":"structures are user defined datatype used for storing entities of data. Entity is any real world physical thing.","title":"Structures in C :"},{"location":"c/20-structures/#why-we-need-structures","text":"In order to store data in a single unit form. To create our own user defined datatype. To create memory location for different datatype in sequential order. To store details of some object. Example : storing id name and age of a student.","title":"Why we need structures ?"},{"location":"c/20-structures/#where-structure-could-be-useful","text":"Let's say we need to store student name and age, then c program for it could be like this without structure : int main(){ char name[20]; int age; printf(\"Enter student name :\\t\"); scanf(\"%s\",name); // remember array name itself holds memory address of base location or address of zero index element. printf(\"Enter student age :\\t\"); scanf(\"%d\",&age); printf(\"%s has age of %d\",name,age); return 0; } In order to keep details of student in such manner, c does not guarantee us that name and age variable will be in sequential order.","title":"Where structure could be useful ?"},{"location":"c/20-structures/#real-life-usage-of-structures","text":"1. In order to create a metro ticketing system, developers needed a tool to store data about issuer, client, price, from, to, and so many other details. So, they used structures to implement the same. 2. facebook uses structures to store data of person, posts, comments.... 3. Telecom company uses structures to store data...","title":"Real Life usage of Structures :"},{"location":"c/20-structures/#how-does-a-structure-looks","text":"struct Rect{ double breadth; double length; } typedef struct Rect Rect; int main(){ Rect x; x.length = 100; x.breadth = 200; printf(\"Rect has length %ld and breadth %ld\\n\", x.length, x.breadth ); return 0; }","title":"How does a structure looks :"},{"location":"c/20-structures/#syntax-of-structure-definition","text":"struct structure_name{ datatype value1; datatype value2; datatype value3; }; // Example struct Rectangle{ double length; double breadth; };","title":"Syntax of Structure Definition :"},{"location":"c/20-structures/#syntax-of-structure-with-variables-inside-code","text":"int main(){ struct structure_name variable_name; //Example struct Rectangle rect1; return 0; }","title":"Syntax of Structure with variables inside code :"},{"location":"c/20-structures/#accessing-elements-of-structure","text":"int main(){ struct Rectangle rect1; printf(\"Length = %ld\\n\",rect1.length); printf(\"Breadth = %d\\n\",rect1.breadth); return 0; }","title":"Accessing Elements of Structure :"},{"location":"c/20-structures/#rules-for-structures","text":"Naming of structure is same as variable name. Structure definition starts with struct reserved keyword of c. Structure definition ends with a semicolon. Structure could contain different datatypes. Structures are accessed using direct member accessor operator (.) or period. Structures are could also be accessed using indirect member accesor operator ( -> ) Variables inside body of structure are allocated sequential poitions. Function declaration is not allowed inside structures. Structures are used to create variables of own defined type with a specific syntax (struct struct_name variable_name ); Variables in body of structure cannot be assigned direct values. By default all elements of structure gets garbage value. Structure name is mapped to first element in struct.","title":"Rules for structures :"},{"location":"c/20-structures/#example-of-struct","text":"struct Rect{ double length; double breadth; }; int main(){ struct Rect rect1; // garbage value proof. printf(\"Length : %ld and Breadth : %ld\\n\",rect1.length, rect1.breadth); // set custom values to rect1 rect1.length = 100; rect1.breadth = 200; printf(\"Length : %ld and Breadth : %ld\\n\",rect1.length, rect1.breadth); return 0; }","title":"Example of struct"},{"location":"c/20-structures/#direct-member-accessor-operator-direct-component-selector-operator","text":"period or dot is called as direct member accessor operator. It is a binary operators means, requires two inputs : first input : variable_name second input : property name or struct member name.","title":"Direct Member accessor operator / Direct Component selector operator:"},{"location":"c/20-structures/#memory-formation-of-structure","text":"example : struct Sample{ char grade; char blood_group; }; Memory: [][][][][][][][] [][][][][][][][][] Variable grade blood_group Address 520620 520621 Size 1 byte 1 byte","title":"Memory Formation of Structure :"},{"location":"c/20-structures/#total-size-of-structure-depends-on-datatypes-used-inside-body-of-struct","text":"","title":"Total size of structure depends on datatypes used inside body of struct."},{"location":"c/20-structures/#preventing-use-of-struct-every-time-we-create-a-variable","text":"struct Rect{ double length; double bredth; }; typedef struct Rect Rect; int main(int argc, char const *argv[]) { Rect rect1; rect1.length = 10; rect2.breadth = 20; printf(\"length : %ld, breadth : %ld\\n\",rect1.length, rect2.length); return 0; }","title":"Preventing use of struct every time we create a variable :"},{"location":"c/20-structures/#another-syntax-of-using-typedef","text":"//direct use of typedef to create struct. typedef struct{ double length; double breadth; } Rect; int main(){ Rect rect1; // some related code. return 0; }","title":"Another syntax of using typedef :"},{"location":"c/20-structures/#using-functions-to-print-elements-of-structure","text":"struct Rect{ int length; int breadth; }; typedef struct Rect Rect; void display(Rect rect){ printf(\"length : %d, breadth : %d\\n\", rect.length, rect.breadth); } int main(int argc, char const *argv[]) { Rect rect1; Rect rect2 = {100, 200}; rect1.length = 20; rect1.breadth = 30; // code consumes high memory due to clone formation in stack. display(rect1); display(rect2); return 0; }","title":"Using Functions to Print Elements of structure :"},{"location":"c/20-structures/#advantages-of-use-with-pointers","text":"Less memory space is required by application. Cloning of struct datatype is prevented. Variables in local scope could be manipulated. Reduces number of operations in STACK formation.","title":"Advantages of use with pointers :"},{"location":"c/20-structures/#pointers-with-struct","text":"typedef struct{ int length; int breadth; } Rect; int main(int argc, char const *argv[]) { Rect rect1; Rect *ptr; ptr = &rect1; ptr->length = 100; ptr->breadth = 200; printf(\"Length : %d and Breadth : %d\\n\",rect1.length, rect1.breadth); return 0; }","title":"Pointers with struct :"},{"location":"c/20-structures/#indirect-member-access-operator-indirect-component-selector-operator-","text":"It is a binary operator, hence takes two inputs first : address of variable second : member of struct.","title":"Indirect Member Access Operator/ Indirect Component Selector Operator ( -&gt; ):"},{"location":"c/20-structures/#difference-in-size-of-pointers-and-struct","text":"typedef struct{ int length; int breadth; } Rect; int main(int argc, char const *argv[]) { Rect rect1; Rect *ptr; printf(\"Size of rect1 is %lu bytes\\n\", sizeof(rect1)); printf(\"Size of ptr is %lu bytes\\n\", sizeof(ptr)); return 0; }","title":"Difference in size of pointers and struct :"},{"location":"c/20-structures/#passing-pointers-to-functions","text":"typedef struct{ int length; int breadth; } Rect; void print_data(Rect * ptr){ printf(\"length : %d, breadth : %d\\n\",(*ptr).length, ptr -> breadth); } int main(int argc, char const *argv[]) { Rect rect1 = {10, 20}; print_data(&rect1); return 0; }","title":"Passing pointers to functions"},{"location":"c/20-structures/#program-to-get-data-from-user-and-store-in-variable","text":"typedef struct{ int length; int breadth; } Rect; void get_data(Rect *rect){ printf(\"Enter length :\\t\"); scanf(\"%d\",&rect->length); printf(\"Enter breadth:\\t\"); scanf(\"%d\",&rect->breadth); } void print_data(Rect *rect){ printf(\"length : %d, breadth : %d\\n\",(*rect).length, rect->breadth); } int main(int argc, char const *argv[]) { Rect rect1; Rect rect2; get_data(&rect1); get_data(&rect2); print_data(&rect1); print_data(&rect2); return 0; }","title":"program to get data from user and store in variable :"},{"location":"c/20-structures/#return-data-from-user-defined-function","text":"// write a program in c to compare two rectangles. struct Rect{ int length; int breadth; }; typedef struct Rect Rect; Rect * compare(Rect const *rect1, Rect const *rect2){ int area1 = rect1->length * rect1->breadth; int area2 = rect2->length * rect2->breadth; return (area1 > area2) ? rect1 : rect2; } int main(int argc, char const *argv[]) { Rect rect1 = {100, 200}; Rect rect2 = {200, 400}; Rect const * result = compare(&rect1, &rect2); printf(\"length : %d, breadth : %d\\n\",result->length, result->breadth); return 0; }","title":"Return data from user defined function :"},{"location":"c/20-structures/#write-a-program-in-c-to-add-two-rectangles","text":"struct Rect{ int length; int breadth; }; typedef struct Rect Rect; Rect add_rectangle(const Rect *rect1, Rect const *rect2){ Rect temp; temp.length = rect1 -> length + rect2 -> length; temp.breadth = rect1 -> breadth + rect2 -> breadth; return temp; } int main(int argc, char const *argv[]) { Rect rect1 = {10, 20}; Rect rect2 = {50, 60}; Rect resultant = add_rectangle(&rect1, &rect2); printf(\"Resultant Rectangle, length : %d and breadth : %d\\n\", resultant.length, resultant.breadth); return 0; }","title":"Write a program in c to add two rectangles :"},{"location":"c/20-structures/#write-a-program-in-c-to-store-data-of-10-employees","text":"#include<stdio_ext.h> #define NUMBER_OF_CLIENTS 10 // could create seperate header file for this info. struct Employee{ char name[20]; int age; int salary; }; typedef struct Employee Employee; void getClientData(Employee *client){ printf(\"Enter employee name :\\t\"); scanf(\"%s\",&client->name); __fpurge(stdin); printf(\"Enter employee age :\\t\"); scanf(\"%d\",&client->age); __fpurge(stdin); printf(\"Enter employee salary :\\t\"); scanf(\"%d\",&client->salary); __fpurge(stdin); } int main(int argc, char const *argv[]) { Employee client[NUMBER_OF_CLIENTS] = {\"\", 0, 0}; int index = 0; while(1){ printf(\"Enter y to add record and q to quit..\\t\"); char ch = getchar(); if(ch == 'q') break; getClientData(&client[index]); index++; } for(int i = 0; i <2; i++){ printf(\"%s, %d, %d\\n\",client[i].name, client[i].age, client[i].salary); } return 0; }","title":"Write a program in c to store data of 10 employees."},{"location":"c/21-file-handling/","text":"File handling in C : File handling is API of C used to interact with OS and buffer to read or write or work with files. Files : Collection of related info is called as file. or Collection of number of bytes when written on harddrive is called a file. File Operation : We can execute four operations on any file : Open Read Write Close Why File handling ? Hard Disk Contains all your files. Files are managed by OS. But OS cannot change contents of a file itself. Some Program/Software is required to provide data to OS to write it to file. Examples : Notepad for text files, VLC for audio video files...etc... What happens during program execution? Program is Executed It gets some memory in RAM. Program creates BUFFER for file handling. Data is loaded in BUFFER Data is manipulated in BUFFER. OS flushes buffer and writes data to file. Program Terminates. Why we need buffer ? Because speed of Hard Disk is slow than RAM. What will happen if Program interacts direct with files on HDD ? Program Loads in RAM and executes from RAM. RAM has much much faster speed than Hard Disk. File is present in Hard Disk. If program interacts with File present on Hard Disk or secondary storage, then Speed of Program execution will not match with file read or write. Hence, 1. Program will require a large time to complete its execution. 2. Will result in slow speed C File Handling : Program ----> BUFFER ----> File_on_hard_disk Functions for file handling : Function Name Description fputc() Writes single character in buffer fputs() Writes string to buffer fopen() Opens buffer as per mode ({'a'}append, {'r'}read, {'w'}write) fclose() Closes and flushes buffer fgetc() Reads single character from buffer fgets() Reads single string from buffer feof() Checks if end of file is reached. fprintf() Writes formatted data to buffer. fseek() Changes current reading/writing position in file buffer. ftell() Returns current reading/writing position in file buffer. fwrite() Writes structure data to file with datatype info in encrypted form fread() Reads data from file stored in form of structures How C handles file details : To manage file details, C uses structure to store file info. FILE is structure name, declared in stdio.h fopen() returns pointer to FILE struct, this pointer is then later used for file manipulation. // sample code #include<stdio.h> int main(int argc, char const *argv[]) { FILE *document; document = fopen(\"/home/jayant/testing.txt\",\"r\"); fclose(); return 0; } Note : Complete file content cannot be loaded to buffer at once, because BUFFER size allocated to application is limited. fopen 1. It is a function of C. 2. Used to create BUFFER in RAM. 3. Loads content of file to buffer as per requirement. 4. Returns NULL if unable to open. Syntax : int main(int argc, char const *argv[]) { fopen(pointer_to_file_location, pointer_to_file_mode); // Visual picture : FILE * fopen(const char *loc, const char *mode); file modes : 1. Read ---->allows read only operations 2. Write ---->allows overwrite operations 3. Append ---->allows appending operations (adds text after end of file) return 0; } Example of fopen() #include<stdio.h> int main(int argc, char const *argv[]) { FILE *document; document = fopen(\"/home/jayant/temp/file.c\"); if(document == NULL) return 0; // some operation on file. fclose(document); //closes file buffer. return 0; } fclose() Function of C. Closes File stream or buffer. Flushes buffer. Informs OS to release memory allocated for file by program. Syntax : #include<stdio.h> int main(int argc, char const *argv[]) { // open buffer using fopen() fclose(pointer_to_buffer); //Visual appearence fclose(const FILE *buffer); return 0; } Example of fclose() : #include<stdio.h> int main(int argc, char const *argv[]) { FILE *document; document = fopen(\"/home/jayant/temp/file.c\",\"w\"); if(document == NULL) return 0; // some action to ececute on file fclose(document); return 0; } fputc() Writes a single character at an instance to BUFFER. Returns ascii value of charcter written. Synatx : int main(int argc, char const *argv[]) { int fputc(letter_to_write, pointer_to_buffer); // Visual Appearence extern int fputc (int __c, FILE *__stream); return 0; } Example of fputc() #include<stdio.h> int main(int argc, char const *argv[]) { FILE *doc; doc = fopen(\"/home/jayant/temp/file.c\",\"a\"); if(document == NULL) return 0; char result = fputs('A', doc); printf(\"Returned : %c\", result); fclose(doc); return 0; } #include<stdio.h> int main(int argc, char const *argv[]) { FILE *doc; doc = fopen(\"/home/jayant/temp/file.c\",\"a\"); if(document == NULL) return 0; for(char ch = 'A'; ch <= 'Z'; ch++){ fputc(ch, doc); } fclose(doc); return 0; } fputs() writes a string to buffer. returns 1 on success and -1 on failure(when mode of file is read only). syntax : extern int fputs (const char *__restrict __s, FILE *__restrict __stream); // Visual look fputs(pointer_to_string, pointer_to_buffer); Example of fputs() #include<stdio.h> int main(int argc, char const *argv[]) { FILE *doc; doc = fopen(\"/home/jayant/temp/file.c\",\"w\"); if(document == NULL) return 0; int result = fputs(\"Jayant\", doc); printf(\"%d\\n\",result); fclose(doc); return 0; } You can use stdout as buffer to print on screen using fgets() fgetc() used to read character from buffer. Returns character fetched. Syntax : extern int fgetc (FILE *__stream); // Visual Appearence fgetc(pointer_to_buffer); Example of getc() #include<stdio.h> int main(int argc, char const *argv[]) { FILE *document; document = fopen(\"/home/jayant/temp/file.c\",\"r\"); if(document == NULL) return 0; char result = fgetc(document); printf(\"Result is %c\\n\",result); fclose(); return 0; } #include<stdio.h> int main(int argc, char const *argv[]) { FILE *document; document = fopen(\"/home/jayant/temp/file.c\",\"r\"); if(document == NULL) return 0; //reads 10 charcater from file for(int i = 0; i < 11; i++){ printf(\"%c\", fgetc(document)); } return 0; } fgets() Used to read string from BUFFER Reads till newline character '\\n' Returns pointer to destination string variable which is manipulated to store result.(same as first argument of fgets) Always terminates itself even if length provided in function is less than no of words read. Writes newline character in string if any and always places null character at the end. Syntax: extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream); //Visual Appearence fgets(destination_string_to_write, length_of_string_to_read, pointer_to_buffer); feof() Known as file end of file. Checks whether there is end of file reached in buffer. Returns 0 on completion is not reached and non zero on completion. Syntax : extern int feof (FILE *__stream) __THROW __wur; //Visual Appereance feof(pointer_to_buffer); Examples of feof() #include<stdio.h> int main(int argc, char const *argv[]) { FILE *document; char *message; document = fopen(\"/home/jayant/temp/file.c\",\"r\"); while(feof(document) == 0){ // !feof(document) fgets(message, , document); } fclose(document); return 0; } fprintf() Function to write formatted output to file Provide pointer_to_buffer to printf() function and you get fprintf() function. Syntax : extern int fprintf (FILE *__restrict __stream, const char *__restrict __format, ...); // Visual Appereance : fprintf(pointer_to_buffer, same_as_printf_arguments); Example of fprintf() : #include<stdio.h> int main(int argc, char const *argv[]) { FILE *doc; int name[10] = \"Jayant Malik\"; doc = fopen(\"/home/jayant/temp/file.c\",\"a\"); fprintf(doc, \"\\nThis is a nice message for %s\",name); fclose(); return 0; } Examples : Write a program to create simple implementation of cat command in linux. #include <stdio.h> int main(int argc, char const *argv[]) { FILE *document; char message[100]; document = fopen(argv[1], \"r\"); if(document == NULL){ printf(\"Error while processing request.\\n\"); return 0; } while(!feof(document)){ fgets(message, 95, document); printf(\"%s\",message); } printf(\"\\n\"); return 0; } Write a program to create simple implementation of less command in linux. #include <stdio.h> int main(int argc, char const *argv[]) { FILE *document; char message[100]; document = fopen(argv[1], \"r\"); if(document == NULL){ printf(\"Error while processing request.\\n\"); return 0; } while(!feof(document)){ fgets(message, 95, document); printf(\"%s\",message); getc(stdin); printf(\"\\033[1A\"); } printf(\"\\n\"); return 0; } Handling data with dataype info : C provides us fwrite() and fread() function to read and write data to file in binary form or encrypted form. fwrite() writes data stored in structure variable of program to file in encrypted form. preserves datatype info of data. do not store entire data in form of string. Syntax : extern size_t fwrite (const void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __s); // Visual Appereance fwrite(address_of_structure, number_of_bytes, units_of_structures, pointer_to_file); number_of_bytes can also be called as size_of_structure units_of_structure is used in case, when we have array of type structure demonstrated in example. Examples of fwrite() : #include<stdio.h> struct Employee{ char name[20]; int age; double salary; }; typedef struct Employee Employee; void getClientData(Employee *client){ printf(\"Enter employee name :\\t\"); scanf(\"%s\",&client->name); printf(\"Enter employee age :\\t\"); scanf(\"%d\",&client->age); printf(\"Enter employee salary :\\t\"); scanf(\"%lf\",&client->salary); } int main(int argc, char const *argv[]) { FILE *document; document = fopen(\"/home/jayant/temp/client_info.data\",\"a\"); if(document == NULL) return 0; Employee client; getClientData(&client); fwrite( (char *)&client, sizeof(Employee), 1, document); // Note here 1 us passed as third argument because //we have single unit of structure not array // if we had an array then we would have passed number of elements // as argument to fwrite() fclose(document); return 0; } Data written in above case is not readable by any text editor. // program to accept data of n employees. #include<stdio_ext.h> #define NUMBER_OF_CLIENTS 10 // could create seperate header file for this info. struct Employee{ char name[20]; int age; int salary; }; typedef struct Employee Employee; void getClientData(Employee *client){ printf(\"Enter employee name :\\t\"); scanf(\"%s\",&client->name); __fpurge(stdin); printf(\"Enter employee age :\\t\"); scanf(\"%d\",&client->age); __fpurge(stdin); printf(\"Enter employee salary :\\t\"); scanf(\"%d\",&client->salary); __fpurge(stdin); } int main(int argc, char const *argv[]) { FILE *document; Employee client[NUMBER_OF_CLIENTS] = {\"\", 0, 0}; int index = 0; document = fopen(\"/home/jayant/temp/client_info.txt\",\"a\"); if(document == NULL) return 0; while(1){ printf(\"Enter y to add record and q to quit..\\t\"); char ch = getchar(); if(ch == 'q') break; getClientData(&client[index]); index++; } fwrite((char *)&client, sizeof(Employee), NUMBER_OF_CLIENTS, document); // here NUMBER_OF_CLIENTS are passed as input to function // because client structure contains NUMBER_OF_CLIENTS units. printf(\"Record added successfully...\"); fclose(document); return 0; } fread() Used to read data from file. Reads encrypted data with data type information. Syntax : #include<stdio_ext.h> #define NUMBER_OF_CLIENTS 10 // could create seperate header file for this info. struct Employee{ char name[20]; int age; int salary; }; typedef struct Employee Employee; void getClientData(Employee *client){ printf(\"Enter employee name :\\t\"); scanf(\"%s\",&client->name); __fpurge(stdin); printf(\"Enter employee age :\\t\"); scanf(\"%d\",&client->age); __fpurge(stdin); printf(\"Enter employee salary :\\t\"); scanf(\"%d\",&client->salary); __fpurge(stdin); } int main(int argc, char const *argv[]) { FILE *document; Employee client[NUMBER_OF_CLIENTS] = {\"\", 0, 0}; int index = 0; document = fopen(\"/home/jayant/temp/client_info.txt\",\"r\"); if(document == NULL) return 0; while(1){ printf(\"Enter y to add record and q to quit..\\t\"); char ch = getchar(); if(ch == 'q') break; getClientData(&client[index]); index++; } fread((char *)&client, sizeof(Employee), NUMBER_OF_CLIENTS, document); for(int i = 0; i < NUMBER_OF_CLIENTS; i++){ printf(\"Name : %s\\nAge : %d\\nSalary : %d\\n\",client[i].name, client[i].age, client[i].salary); printf(\"============================\\n\"); } fclose(document); return 0; } ftell() Returns current read write position in file buffer. After creation of buffer position is 0. File always ends with a character EOF or End Of File. Syntax : extern long int ftell (FILE *__stream) __wur; // Visual Appearence : ftell(pointer_to_file); Examples of ftell() #include<stdio.h> int main(int argc, char const *argv[]) { FILE *document; document = fopen(\"/home/jayant/temp/file.c\", \"r\"); if(document == NULL) return 0; int position = ftell(document); printf(\"Position at start is %d\\n\", position); fgetc(document); // reads first character at 0 and changes position to 1. position = ftell(document); printf(\"Position after fgetc %d\\n\", position); fclose(document); return 0; } fseek() Used to change current read write position in file buffer. Supports three mode : beginning position, current position, end position. beginning --> 0, current --> 1, end --> 2 Syntax: extern int fseek (FILE *__stream, long int __off, int __whence); // Visual Apperence : fseek(pointer_to_file, number_of_bytes, position_to_start_from); Examples of fseek() : #include<stdio.h> int main(int argc, char const *argv[]) { FILE *document; document = fopen(\"/home/jayant/temp/file.c\", \"r\"); if(document == NULL) return 0; int position = ftell(document); printf(\"Position at start is %d\\n\", position); fseek(document, 10, 0); // from beginning position = ftell(document); printf(\"Position after fgetc %d\\n\", position); fclose(document); return 0; } #include<stdio.h> int main(int argc, char const *argv[]) { FILE *document; document = fopen(\"/home/jayant/temp/file.c\", \"r\"); if(document == NULL) return 0; int position = ftell(document); printf(\"Position at start is %d\\n\", position); fseek(document, -3, 1); // from ending position = ftell(document); printf(\"Position after fgetc %d\\n\", position); fclose(document); return 0; } Write a program in C to count number of letters in a file. #include<stdio.h> int main(int argc, char const *argv[]) { FILE *src; src = fopen(\"/home/jayant/temp/file.c\", \"r\"); if(src == NULL) return 0; fseek(src, 0, 2); int letters_count = ftell(src); printf(\"Total letters in file are : %d\\n\",letters_count); fclose(src); return 0; }","title":"21. File Handling"},{"location":"c/21-file-handling/#file-handling-in-c","text":"File handling is API of C used to interact with OS and buffer to read or write or work with files.","title":"File handling in C :"},{"location":"c/21-file-handling/#files","text":"Collection of related info is called as file. or Collection of number of bytes when written on harddrive is called a file.","title":"Files :"},{"location":"c/21-file-handling/#file-operation","text":"We can execute four operations on any file : Open Read Write Close","title":"File Operation :"},{"location":"c/21-file-handling/#why-file-handling","text":"Hard Disk Contains all your files. Files are managed by OS. But OS cannot change contents of a file itself. Some Program/Software is required to provide data to OS to write it to file. Examples : Notepad for text files, VLC for audio video files...etc...","title":"Why File handling ?"},{"location":"c/21-file-handling/#what-happens-during-program-execution","text":"Program is Executed It gets some memory in RAM. Program creates BUFFER for file handling. Data is loaded in BUFFER Data is manipulated in BUFFER. OS flushes buffer and writes data to file. Program Terminates.","title":"What happens during program execution?"},{"location":"c/21-file-handling/#why-we-need-buffer","text":"Because speed of Hard Disk is slow than RAM.","title":"Why we need buffer ?"},{"location":"c/21-file-handling/#what-will-happen-if-program-interacts-direct-with-files-on-hdd","text":"Program Loads in RAM and executes from RAM. RAM has much much faster speed than Hard Disk. File is present in Hard Disk. If program interacts with File present on Hard Disk or secondary storage, then Speed of Program execution will not match with file read or write. Hence, 1. Program will require a large time to complete its execution. 2. Will result in slow speed","title":"What will happen if Program interacts direct with files on HDD ?"},{"location":"c/21-file-handling/#c-file-handling","text":"Program ----> BUFFER ----> File_on_hard_disk","title":"C File Handling :"},{"location":"c/21-file-handling/#functions-for-file-handling","text":"Function Name Description fputc() Writes single character in buffer fputs() Writes string to buffer fopen() Opens buffer as per mode ({'a'}append, {'r'}read, {'w'}write) fclose() Closes and flushes buffer fgetc() Reads single character from buffer fgets() Reads single string from buffer feof() Checks if end of file is reached. fprintf() Writes formatted data to buffer. fseek() Changes current reading/writing position in file buffer. ftell() Returns current reading/writing position in file buffer. fwrite() Writes structure data to file with datatype info in encrypted form fread() Reads data from file stored in form of structures","title":"Functions for file handling :"},{"location":"c/21-file-handling/#how-c-handles-file-details","text":"To manage file details, C uses structure to store file info. FILE is structure name, declared in stdio.h fopen() returns pointer to FILE struct, this pointer is then later used for file manipulation. // sample code #include<stdio.h> int main(int argc, char const *argv[]) { FILE *document; document = fopen(\"/home/jayant/testing.txt\",\"r\"); fclose(); return 0; }","title":"How C handles file details :"},{"location":"c/21-file-handling/#note-complete-file-content-cannot-be-loaded-to-buffer-at-once-because-buffer-size-allocated-to-application-is-limited","text":"","title":"Note : Complete file content cannot be loaded to buffer at once, because BUFFER size allocated to application is limited."},{"location":"c/21-file-handling/#fopen","text":"1. It is a function of C. 2. Used to create BUFFER in RAM. 3. Loads content of file to buffer as per requirement. 4. Returns NULL if unable to open. Syntax : int main(int argc, char const *argv[]) { fopen(pointer_to_file_location, pointer_to_file_mode); // Visual picture : FILE * fopen(const char *loc, const char *mode); file modes : 1. Read ---->allows read only operations 2. Write ---->allows overwrite operations 3. Append ---->allows appending operations (adds text after end of file) return 0; }","title":"fopen"},{"location":"c/21-file-handling/#example-of-fopen","text":"#include<stdio.h> int main(int argc, char const *argv[]) { FILE *document; document = fopen(\"/home/jayant/temp/file.c\"); if(document == NULL) return 0; // some operation on file. fclose(document); //closes file buffer. return 0; }","title":"Example of fopen()"},{"location":"c/21-file-handling/#fclose","text":"Function of C. Closes File stream or buffer. Flushes buffer. Informs OS to release memory allocated for file by program. Syntax : #include<stdio.h> int main(int argc, char const *argv[]) { // open buffer using fopen() fclose(pointer_to_buffer); //Visual appearence fclose(const FILE *buffer); return 0; }","title":"fclose()"},{"location":"c/21-file-handling/#example-of-fclose","text":"#include<stdio.h> int main(int argc, char const *argv[]) { FILE *document; document = fopen(\"/home/jayant/temp/file.c\",\"w\"); if(document == NULL) return 0; // some action to ececute on file fclose(document); return 0; }","title":"Example of fclose() :"},{"location":"c/21-file-handling/#fputc","text":"Writes a single character at an instance to BUFFER. Returns ascii value of charcter written. Synatx : int main(int argc, char const *argv[]) { int fputc(letter_to_write, pointer_to_buffer); // Visual Appearence extern int fputc (int __c, FILE *__stream); return 0; }","title":"fputc()"},{"location":"c/21-file-handling/#example-of-fputc","text":"#include<stdio.h> int main(int argc, char const *argv[]) { FILE *doc; doc = fopen(\"/home/jayant/temp/file.c\",\"a\"); if(document == NULL) return 0; char result = fputs('A', doc); printf(\"Returned : %c\", result); fclose(doc); return 0; } #include<stdio.h> int main(int argc, char const *argv[]) { FILE *doc; doc = fopen(\"/home/jayant/temp/file.c\",\"a\"); if(document == NULL) return 0; for(char ch = 'A'; ch <= 'Z'; ch++){ fputc(ch, doc); } fclose(doc); return 0; }","title":"Example of fputc()"},{"location":"c/21-file-handling/#fputs","text":"writes a string to buffer. returns 1 on success and -1 on failure(when mode of file is read only). syntax : extern int fputs (const char *__restrict __s, FILE *__restrict __stream); // Visual look fputs(pointer_to_string, pointer_to_buffer);","title":"fputs()"},{"location":"c/21-file-handling/#example-of-fputs","text":"#include<stdio.h> int main(int argc, char const *argv[]) { FILE *doc; doc = fopen(\"/home/jayant/temp/file.c\",\"w\"); if(document == NULL) return 0; int result = fputs(\"Jayant\", doc); printf(\"%d\\n\",result); fclose(doc); return 0; }","title":"Example of fputs()"},{"location":"c/21-file-handling/#you-can-use-stdout-as-buffer-to-print-on-screen-using-fgets","text":"","title":"You can use stdout as buffer to print on screen using fgets()"},{"location":"c/21-file-handling/#fgetc","text":"used to read character from buffer. Returns character fetched. Syntax : extern int fgetc (FILE *__stream); // Visual Appearence fgetc(pointer_to_buffer);","title":"fgetc()"},{"location":"c/21-file-handling/#example-of-getc","text":"#include<stdio.h> int main(int argc, char const *argv[]) { FILE *document; document = fopen(\"/home/jayant/temp/file.c\",\"r\"); if(document == NULL) return 0; char result = fgetc(document); printf(\"Result is %c\\n\",result); fclose(); return 0; } #include<stdio.h> int main(int argc, char const *argv[]) { FILE *document; document = fopen(\"/home/jayant/temp/file.c\",\"r\"); if(document == NULL) return 0; //reads 10 charcater from file for(int i = 0; i < 11; i++){ printf(\"%c\", fgetc(document)); } return 0; }","title":"Example of getc()"},{"location":"c/21-file-handling/#fgets","text":"Used to read string from BUFFER Reads till newline character '\\n' Returns pointer to destination string variable which is manipulated to store result.(same as first argument of fgets) Always terminates itself even if length provided in function is less than no of words read. Writes newline character in string if any and always places null character at the end. Syntax: extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream); //Visual Appearence fgets(destination_string_to_write, length_of_string_to_read, pointer_to_buffer);","title":"fgets()"},{"location":"c/21-file-handling/#feof","text":"Known as file end of file. Checks whether there is end of file reached in buffer. Returns 0 on completion is not reached and non zero on completion. Syntax : extern int feof (FILE *__stream) __THROW __wur; //Visual Appereance feof(pointer_to_buffer);","title":"feof()"},{"location":"c/21-file-handling/#examples-of-feof","text":"#include<stdio.h> int main(int argc, char const *argv[]) { FILE *document; char *message; document = fopen(\"/home/jayant/temp/file.c\",\"r\"); while(feof(document) == 0){ // !feof(document) fgets(message, , document); } fclose(document); return 0; }","title":"Examples of feof()"},{"location":"c/21-file-handling/#fprintf","text":"Function to write formatted output to file Provide pointer_to_buffer to printf() function and you get fprintf() function. Syntax : extern int fprintf (FILE *__restrict __stream, const char *__restrict __format, ...); // Visual Appereance : fprintf(pointer_to_buffer, same_as_printf_arguments);","title":"fprintf()"},{"location":"c/21-file-handling/#example-of-fprintf","text":"#include<stdio.h> int main(int argc, char const *argv[]) { FILE *doc; int name[10] = \"Jayant Malik\"; doc = fopen(\"/home/jayant/temp/file.c\",\"a\"); fprintf(doc, \"\\nThis is a nice message for %s\",name); fclose(); return 0; }","title":"Example of fprintf() :"},{"location":"c/21-file-handling/#examples","text":"","title":"Examples :"},{"location":"c/21-file-handling/#write-a-program-to-create-simple-implementation-of-cat-command-in-linux","text":"#include <stdio.h> int main(int argc, char const *argv[]) { FILE *document; char message[100]; document = fopen(argv[1], \"r\"); if(document == NULL){ printf(\"Error while processing request.\\n\"); return 0; } while(!feof(document)){ fgets(message, 95, document); printf(\"%s\",message); } printf(\"\\n\"); return 0; }","title":"Write a program to create simple implementation of cat command in linux."},{"location":"c/21-file-handling/#write-a-program-to-create-simple-implementation-of-less-command-in-linux","text":"#include <stdio.h> int main(int argc, char const *argv[]) { FILE *document; char message[100]; document = fopen(argv[1], \"r\"); if(document == NULL){ printf(\"Error while processing request.\\n\"); return 0; } while(!feof(document)){ fgets(message, 95, document); printf(\"%s\",message); getc(stdin); printf(\"\\033[1A\"); } printf(\"\\n\"); return 0; }","title":"Write a program to create simple implementation of less command in linux."},{"location":"c/21-file-handling/#handling-data-with-dataype-info","text":"C provides us fwrite() and fread() function to read and write data to file in binary form or encrypted form.","title":"Handling data with dataype info :"},{"location":"c/21-file-handling/#fwrite","text":"writes data stored in structure variable of program to file in encrypted form. preserves datatype info of data. do not store entire data in form of string. Syntax : extern size_t fwrite (const void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __s); // Visual Appereance fwrite(address_of_structure, number_of_bytes, units_of_structures, pointer_to_file); number_of_bytes can also be called as size_of_structure units_of_structure is used in case, when we have array of type structure demonstrated in example.","title":"fwrite()"},{"location":"c/21-file-handling/#examples-of-fwrite","text":"#include<stdio.h> struct Employee{ char name[20]; int age; double salary; }; typedef struct Employee Employee; void getClientData(Employee *client){ printf(\"Enter employee name :\\t\"); scanf(\"%s\",&client->name); printf(\"Enter employee age :\\t\"); scanf(\"%d\",&client->age); printf(\"Enter employee salary :\\t\"); scanf(\"%lf\",&client->salary); } int main(int argc, char const *argv[]) { FILE *document; document = fopen(\"/home/jayant/temp/client_info.data\",\"a\"); if(document == NULL) return 0; Employee client; getClientData(&client); fwrite( (char *)&client, sizeof(Employee), 1, document); // Note here 1 us passed as third argument because //we have single unit of structure not array // if we had an array then we would have passed number of elements // as argument to fwrite() fclose(document); return 0; }","title":"Examples of fwrite() :"},{"location":"c/21-file-handling/#data-written-in-above-case-is-not-readable-by-any-text-editor","text":"// program to accept data of n employees. #include<stdio_ext.h> #define NUMBER_OF_CLIENTS 10 // could create seperate header file for this info. struct Employee{ char name[20]; int age; int salary; }; typedef struct Employee Employee; void getClientData(Employee *client){ printf(\"Enter employee name :\\t\"); scanf(\"%s\",&client->name); __fpurge(stdin); printf(\"Enter employee age :\\t\"); scanf(\"%d\",&client->age); __fpurge(stdin); printf(\"Enter employee salary :\\t\"); scanf(\"%d\",&client->salary); __fpurge(stdin); } int main(int argc, char const *argv[]) { FILE *document; Employee client[NUMBER_OF_CLIENTS] = {\"\", 0, 0}; int index = 0; document = fopen(\"/home/jayant/temp/client_info.txt\",\"a\"); if(document == NULL) return 0; while(1){ printf(\"Enter y to add record and q to quit..\\t\"); char ch = getchar(); if(ch == 'q') break; getClientData(&client[index]); index++; } fwrite((char *)&client, sizeof(Employee), NUMBER_OF_CLIENTS, document); // here NUMBER_OF_CLIENTS are passed as input to function // because client structure contains NUMBER_OF_CLIENTS units. printf(\"Record added successfully...\"); fclose(document); return 0; }","title":"Data written in above case is not readable by any text editor."},{"location":"c/21-file-handling/#fread","text":"Used to read data from file. Reads encrypted data with data type information. Syntax : #include<stdio_ext.h> #define NUMBER_OF_CLIENTS 10 // could create seperate header file for this info. struct Employee{ char name[20]; int age; int salary; }; typedef struct Employee Employee; void getClientData(Employee *client){ printf(\"Enter employee name :\\t\"); scanf(\"%s\",&client->name); __fpurge(stdin); printf(\"Enter employee age :\\t\"); scanf(\"%d\",&client->age); __fpurge(stdin); printf(\"Enter employee salary :\\t\"); scanf(\"%d\",&client->salary); __fpurge(stdin); } int main(int argc, char const *argv[]) { FILE *document; Employee client[NUMBER_OF_CLIENTS] = {\"\", 0, 0}; int index = 0; document = fopen(\"/home/jayant/temp/client_info.txt\",\"r\"); if(document == NULL) return 0; while(1){ printf(\"Enter y to add record and q to quit..\\t\"); char ch = getchar(); if(ch == 'q') break; getClientData(&client[index]); index++; } fread((char *)&client, sizeof(Employee), NUMBER_OF_CLIENTS, document); for(int i = 0; i < NUMBER_OF_CLIENTS; i++){ printf(\"Name : %s\\nAge : %d\\nSalary : %d\\n\",client[i].name, client[i].age, client[i].salary); printf(\"============================\\n\"); } fclose(document); return 0; }","title":"fread()"},{"location":"c/21-file-handling/#ftell","text":"Returns current read write position in file buffer. After creation of buffer position is 0. File always ends with a character EOF or End Of File. Syntax : extern long int ftell (FILE *__stream) __wur; // Visual Appearence : ftell(pointer_to_file);","title":"ftell()"},{"location":"c/21-file-handling/#examples-of-ftell","text":"#include<stdio.h> int main(int argc, char const *argv[]) { FILE *document; document = fopen(\"/home/jayant/temp/file.c\", \"r\"); if(document == NULL) return 0; int position = ftell(document); printf(\"Position at start is %d\\n\", position); fgetc(document); // reads first character at 0 and changes position to 1. position = ftell(document); printf(\"Position after fgetc %d\\n\", position); fclose(document); return 0; }","title":"Examples of ftell()"},{"location":"c/21-file-handling/#fseek","text":"Used to change current read write position in file buffer. Supports three mode : beginning position, current position, end position. beginning --> 0, current --> 1, end --> 2 Syntax: extern int fseek (FILE *__stream, long int __off, int __whence); // Visual Apperence : fseek(pointer_to_file, number_of_bytes, position_to_start_from);","title":"fseek()"},{"location":"c/21-file-handling/#examples-of-fseek","text":"#include<stdio.h> int main(int argc, char const *argv[]) { FILE *document; document = fopen(\"/home/jayant/temp/file.c\", \"r\"); if(document == NULL) return 0; int position = ftell(document); printf(\"Position at start is %d\\n\", position); fseek(document, 10, 0); // from beginning position = ftell(document); printf(\"Position after fgetc %d\\n\", position); fclose(document); return 0; } #include<stdio.h> int main(int argc, char const *argv[]) { FILE *document; document = fopen(\"/home/jayant/temp/file.c\", \"r\"); if(document == NULL) return 0; int position = ftell(document); printf(\"Position at start is %d\\n\", position); fseek(document, -3, 1); // from ending position = ftell(document); printf(\"Position after fgetc %d\\n\", position); fclose(document); return 0; }","title":"Examples of fseek() :"},{"location":"c/21-file-handling/#write-a-program-in-c-to-count-number-of-letters-in-a-file","text":"#include<stdio.h> int main(int argc, char const *argv[]) { FILE *src; src = fopen(\"/home/jayant/temp/file.c\", \"r\"); if(src == NULL) return 0; fseek(src, 0, 2); int letters_count = ftell(src); printf(\"Total letters in file are : %d\\n\",letters_count); fclose(src); return 0; }","title":"Write a program in C to count number of letters in a file."},{"location":"c/22-interesting-facts/","text":"We can use <% %> in place of braces. #include<stdio.h> int main(int argc, char const *argv[]) <% printf(\"FILE : %s\\n\",__FILE__); printf(\"TIME : %s\\n\",__TIME__); printf(\"DATE : %s\\n\",__TIME__); printf(\"LINE NUMBER : %d\\n\",__LINE__); return 0; %> We can take keep stdin buffer open till our custom letter is typed : #include<stdio.h> int main() { int age = 0; printf(\"Enter your age :\\t\"); scanf(\"%d[^-]\",&age); printf(\"Your age is %d\\n\",age); return 0; }","title":"22. Interesting Facts"},{"location":"c/22-interesting-facts/#we-can-use-in-place-of-braces","text":"#include<stdio.h> int main(int argc, char const *argv[]) <% printf(\"FILE : %s\\n\",__FILE__); printf(\"TIME : %s\\n\",__TIME__); printf(\"DATE : %s\\n\",__TIME__); printf(\"LINE NUMBER : %d\\n\",__LINE__); return 0; %>","title":"We can use &lt;% %&gt; in place of braces."},{"location":"c/22-interesting-facts/#we-can-take-keep-stdin-buffer-open-till-our-custom-letter-is-typed","text":"#include<stdio.h> int main() { int age = 0; printf(\"Enter your age :\\t\"); scanf(\"%d[^-]\",&age); printf(\"Your age is %d\\n\",age); return 0; }","title":"We can take keep stdin buffer open till our custom letter is typed :"},{"location":"dsa/01-introduction/","text":"Data: Any information that can be encoded and decoded in 0s and 1s , is called Data . Usually data is stored in a file on PC HDD (hard disk drive), or SSD (solid state drive). Data from HDD or SSD is first loaded in RAM , prior to operation on it. A file that hold data and is stored on HDD or SSD is called DATABASE Data Structure: The Structure used to store data on HDD or SSD is called Data Structure Most common used Data Structure for storing data in RAM are: ARRAYS STACK QUEUE Heap Structure Linked List Algorithm: A procedure or steps followed to solve any computational problem is called algorithm . An algorithm can be: Written in human understandable language, such as English , Hindi , and so on... Written in programming language, such as C , C++ , Java , Python , and so on... Example of Algorithm: Let's say we want to write an algorithm to shoot a movie. To achieve the target, we need to break the problem in steps: Buy a Camera, Buy Storage Space for videos Buy the PCs for video editing Hire a team of individuals to shoot the videos Hire someone who knows video editing Shoot the videos Edit the videos Release the movie The above mentioned steps, can be considered as an algorithm for shooting a movie. Similarly, you can write your own steps to solve a problem and that will be your algorithm. How programs work? Programs are just 0s and 1s . These 0s and 1s are loaded in RAM , and thereafter are transferred to processor for execution. The processor calculates the result and stores it back in RAM . The process above is controlled by Operating System . OS Virtual Memory Process Inside RAM Application Virtual Memory Application Virtual Memory A part of memory from RAM is allocated to the application. The memory addresses provided to the application are not physical rather they are generated by OS . Hence, due to virtual addresses provided to application, the memory is often referred as Application Virtual Memory The above figure represents 4 parts of application memory. Each part has its own use and importance. We will provide short description of each part. Text: The text area holds the application 0s and 1s. Usually these 0s and 1s are stored on HDD in form of executable file. The format of storing the executable varies as per the OS. Example: * Windows : .exe, .msi * Linux: No Extension needed * Mac: .app Environment Variables This portion of memory is stores environment variables for our program. Environment variables are used to store information such as: * path to executables for our application * path to libraries for our application And it is also used for various other purposes. Due to limited scope of this content, we will not discuss it in detail. Heap Heap is a part of memory that stores data of our application till the program execution ends . Heap is mainly used during the Dynamic Memory Allocation . Dynamic Memory Allocation is a process of allocating memory to program during runtime . It allows us to change the memory size of some variable. In case of Dynamic memory allocation we can: * Allocate custom memory to application (let's say 100 bytes) Now in future we needed more memory. So, we can ask Operating System to allocate more memory to our previous created variable. Stack Stack is a part of memory that stores data for a small instance of time. In case of programs, function variables are stored inside of STACK . Whenever a function returns some value, the variable is destroyed from RAM . In the program below the age variable will be created and deleted 100 times , because it is formed inside of STACK Example: int main(){ // creating the loop // to demonstrate stack nature for(int i=0; i<100; ++i){ int age = 10; age += 2; printf(\"%d \", age); } return 0; } OS Overview: The OS can be visualized as: * OS * Softwares * Applications * Programs In case of functional programming : * Application * Programs * Functions * Statements In case of Object Oriented Programming : * Application * Programs * Objects * Classes * Methods + Fields * Statements After Visualizing the above content, we can infer that, in case of functional programming: Applications are made up of programs, which are our individual source code files Each source code file has functions , which further has statements . What is DSA? DSA stands for DATA STRUCTURES AND ALGORITHMS . In DSA we study, the science to implement the ideas in programs using, Data Structures (arrays, linked list) and Algorithms (bubble sort, selection sort). Main motives of DSA is to teach you : * How to think like a programmer? * How to break a problem in parts? * How to implement the solution. * How to use the existing tools to model a new concept. DSA is most important, if : * You want to learn Programming * You want to learn Hacking. * You want to patch the securities of your system. * You want to understand the working of OS. * And, there are lot more uses of DSA. Getting Started To introduce the DSA, we can use any programming language. But to be consistent, we will use one languages: C in the following tutorials. If you want to learn about Data Structure, in any other language, then the concepts discussed in this series of lessons, will remain same. So, feel free to implement the algorithms in any other language language, if you like. Try to solve the problems yourself, that makes you learn faster and better. Tools Needed Option 1 We need few tools to get started: * Text Editor * GCC Compiler In case of text editor , we recommend you to use Sublime Text or Atom or VS Code and GCC compiler can be downloaded from MinGW site. For Windows: Note: In order to use the GCC compiler from command line interface in windows, we need to add the installation directory to path. To add the compiler to path follow the steps below: * Navigate to the Compiler Installation directory * Now navigate in bin directory inside compiler installation directory * Copy the complete path: C:\\MinGW\\bin\\ or any other path * Hold the Alt button and double click on 'This Pc' from desktop * Now Select 'Advanced System Settings' from left sidebar * Search for Environment variables inside of 'Advanced' tab and click it. * Now, add the copied path here. * In order to make the changes reflect in your system. Reboot it. For Linux You can use apt or yum package manager sudo apt install build-essential sudo apt install gcc If you are confused in setting up your text editor and Compiler, then follow Option 2 Option 2 We can also use a software called as IDE (INTEGRATED DEVELOPMENT ENVIRONMENT). CodeBlocks DevCpp Netbeans Geany are some of the IDEs that can be used to follow along. Theory or Practical: We try to discuss every topic using a practical approach but there are a few concepts, which needs to just told. So, about 90% of this book after introduction section will be practical. We are happy to get started on our journey with you. The content discussed in this book uses latest programming tools such as: * C11 version of c language * Text Editors used in real world app development. * Solutions using multiple approaches. What's Next? In next, lesson we will start discussing, stack and will try to understand how OS creates the stack. After understanding the concept we will try to implement it on our own. So, let's get started!!!","title":"01. Introduction"},{"location":"dsa/01-introduction/#data","text":"Any information that can be encoded and decoded in 0s and 1s , is called Data . Usually data is stored in a file on PC HDD (hard disk drive), or SSD (solid state drive). Data from HDD or SSD is first loaded in RAM , prior to operation on it. A file that hold data and is stored on HDD or SSD is called DATABASE","title":"Data:"},{"location":"dsa/01-introduction/#data-structure","text":"The Structure used to store data on HDD or SSD is called Data Structure Most common used Data Structure for storing data in RAM are: ARRAYS STACK QUEUE Heap Structure Linked List","title":"Data Structure:"},{"location":"dsa/01-introduction/#algorithm","text":"A procedure or steps followed to solve any computational problem is called algorithm . An algorithm can be: Written in human understandable language, such as English , Hindi , and so on... Written in programming language, such as C , C++ , Java , Python , and so on...","title":"Algorithm:"},{"location":"dsa/01-introduction/#example-of-algorithm","text":"Let's say we want to write an algorithm to shoot a movie. To achieve the target, we need to break the problem in steps: Buy a Camera, Buy Storage Space for videos Buy the PCs for video editing Hire a team of individuals to shoot the videos Hire someone who knows video editing Shoot the videos Edit the videos Release the movie The above mentioned steps, can be considered as an algorithm for shooting a movie. Similarly, you can write your own steps to solve a problem and that will be your algorithm.","title":"Example of Algorithm:"},{"location":"dsa/01-introduction/#how-programs-work","text":"Programs are just 0s and 1s . These 0s and 1s are loaded in RAM , and thereafter are transferred to processor for execution. The processor calculates the result and stores it back in RAM . The process above is controlled by Operating System .","title":"How programs work?"},{"location":"dsa/01-introduction/#os-virtual-memory","text":"","title":"OS Virtual Memory"},{"location":"dsa/01-introduction/#process-inside-ram","text":"","title":"Process Inside RAM"},{"location":"dsa/01-introduction/#application-virtual-memory","text":"","title":"Application Virtual Memory"},{"location":"dsa/01-introduction/#application-virtual-memory_1","text":"A part of memory from RAM is allocated to the application. The memory addresses provided to the application are not physical rather they are generated by OS . Hence, due to virtual addresses provided to application, the memory is often referred as Application Virtual Memory The above figure represents 4 parts of application memory. Each part has its own use and importance. We will provide short description of each part.","title":"Application Virtual Memory"},{"location":"dsa/01-introduction/#text","text":"The text area holds the application 0s and 1s. Usually these 0s and 1s are stored on HDD in form of executable file. The format of storing the executable varies as per the OS. Example: * Windows : .exe, .msi * Linux: No Extension needed * Mac: .app","title":"Text:"},{"location":"dsa/01-introduction/#environment-variables","text":"This portion of memory is stores environment variables for our program. Environment variables are used to store information such as: * path to executables for our application * path to libraries for our application And it is also used for various other purposes. Due to limited scope of this content, we will not discuss it in detail.","title":"Environment Variables"},{"location":"dsa/01-introduction/#heap","text":"Heap is a part of memory that stores data of our application till the program execution ends . Heap is mainly used during the Dynamic Memory Allocation . Dynamic Memory Allocation is a process of allocating memory to program during runtime . It allows us to change the memory size of some variable. In case of Dynamic memory allocation we can: * Allocate custom memory to application (let's say 100 bytes) Now in future we needed more memory. So, we can ask Operating System to allocate more memory to our previous created variable.","title":"Heap"},{"location":"dsa/01-introduction/#stack","text":"Stack is a part of memory that stores data for a small instance of time. In case of programs, function variables are stored inside of STACK . Whenever a function returns some value, the variable is destroyed from RAM . In the program below the age variable will be created and deleted 100 times , because it is formed inside of STACK Example: int main(){ // creating the loop // to demonstrate stack nature for(int i=0; i<100; ++i){ int age = 10; age += 2; printf(\"%d \", age); } return 0; }","title":"Stack"},{"location":"dsa/01-introduction/#os-overview","text":"The OS can be visualized as: * OS * Softwares * Applications * Programs In case of functional programming : * Application * Programs * Functions * Statements In case of Object Oriented Programming : * Application * Programs * Objects * Classes * Methods + Fields * Statements After Visualizing the above content, we can infer that, in case of functional programming: Applications are made up of programs, which are our individual source code files Each source code file has functions , which further has statements .","title":"OS Overview:"},{"location":"dsa/01-introduction/#what-is-dsa","text":"DSA stands for DATA STRUCTURES AND ALGORITHMS . In DSA we study, the science to implement the ideas in programs using, Data Structures (arrays, linked list) and Algorithms (bubble sort, selection sort). Main motives of DSA is to teach you : * How to think like a programmer? * How to break a problem in parts? * How to implement the solution. * How to use the existing tools to model a new concept. DSA is most important, if : * You want to learn Programming * You want to learn Hacking. * You want to patch the securities of your system. * You want to understand the working of OS. * And, there are lot more uses of DSA.","title":"What is DSA?"},{"location":"dsa/01-introduction/#getting-started","text":"To introduce the DSA, we can use any programming language. But to be consistent, we will use one languages: C in the following tutorials. If you want to learn about Data Structure, in any other language, then the concepts discussed in this series of lessons, will remain same. So, feel free to implement the algorithms in any other language language, if you like. Try to solve the problems yourself, that makes you learn faster and better.","title":"Getting Started"},{"location":"dsa/01-introduction/#tools-needed","text":"","title":"Tools Needed"},{"location":"dsa/01-introduction/#option-1","text":"We need few tools to get started: * Text Editor * GCC Compiler In case of text editor , we recommend you to use Sublime Text or Atom or VS Code and GCC compiler can be downloaded from MinGW site.","title":"Option 1"},{"location":"dsa/01-introduction/#for-windows","text":"Note: In order to use the GCC compiler from command line interface in windows, we need to add the installation directory to path. To add the compiler to path follow the steps below: * Navigate to the Compiler Installation directory * Now navigate in bin directory inside compiler installation directory * Copy the complete path: C:\\MinGW\\bin\\ or any other path * Hold the Alt button and double click on 'This Pc' from desktop * Now Select 'Advanced System Settings' from left sidebar * Search for Environment variables inside of 'Advanced' tab and click it. * Now, add the copied path here. * In order to make the changes reflect in your system. Reboot it.","title":"For Windows:"},{"location":"dsa/01-introduction/#for-linux","text":"You can use apt or yum package manager sudo apt install build-essential sudo apt install gcc If you are confused in setting up your text editor and Compiler, then follow Option 2","title":"For Linux"},{"location":"dsa/01-introduction/#option-2","text":"We can also use a software called as IDE (INTEGRATED DEVELOPMENT ENVIRONMENT). CodeBlocks DevCpp Netbeans Geany are some of the IDEs that can be used to follow along.","title":"Option 2"},{"location":"dsa/01-introduction/#theory-or-practical","text":"We try to discuss every topic using a practical approach but there are a few concepts, which needs to just told. So, about 90% of this book after introduction section will be practical. We are happy to get started on our journey with you. The content discussed in this book uses latest programming tools such as: * C11 version of c language * Text Editors used in real world app development. * Solutions using multiple approaches.","title":"Theory or Practical:"},{"location":"dsa/01-introduction/#whats-next","text":"In next, lesson we will start discussing, stack and will try to understand how OS creates the stack. After understanding the concept we will try to implement it on our own. So, let's get started!!!","title":"What's Next?"},{"location":"dsa/02-os-stack/","text":"Intro to Stack: Stack is a part of memory, created during the application runtime. It holds all the local variables and instances of functions in it. Let's say we have a program, consisting of 3 functions as follows: #include <stdio.h> // Function pi float pi(){ return 22/7; } // function calculate float pi_times(int num){ return pi() * num; } // main function int main(int argc, char const *argv[]) { // calculating the pi squared. int squared = pi_times(2); printf(\"PI Squared: %.14f\\n\", squared); return 0; } Note: To visualize the above code working please visit pythontutor.com/c.html Paste the code and press visualize execution button. After pressing visualize button you will see Forward button. Click forward button and see the stack in action. Now, the Operating System needs to solve the functions. In order to solve the above program, The Operating System: * Allocates RAM for program * Loads the program in RAM * Solves each function one by one inside STACK * Free the memory allocated for each function, whenever the function returns some value. * Finally, free the memory reserved for whole program. Let's understand different parts of RAM, allocated by OS. We have already discussed in introduction section, that each program on loading in RAM , loads in 4 different sections. They are: Text Environment Variables Heap Stack Now, in this lesson, we will study one of the memory section from above 4 sections, that is STACK Working of Stack Stack is a data structure, that holds some data. The data could be of any type, such as int, float, char, pointer, structure, union etc. The STACK follows some conditions, which differentiates it from other data structures , that is: * Item in STACK can be inserted and deleted from TOP of STACK. The above terminology \"insertion and deletion from top\" has given STACK a short form LIFO described as, LAST IN FIRST OUT LIFO simply means, the data item inserted at last will be evaluated first. Example to Demonstrate the example: Consider, the STACK as bunch of boxes, each able to store a number. Step 1: Each Box represent a single part of STACK memory Memory | Index [] 0 [] 1 [] 2 [] 3 Adding 1, 2, 3 in the STACK Memory | Index [1] 0 [2] 1 [3] 2 [] 3 Deleting an item from STACK Memory | Index [1] 0 [2] 1 [] 2 [] 3 Adding 5 in the STACK Memory | Index [1] 0 [2] 1 [5] 2 [] 3 Note: You will notice that, * 3 was deleted from stack and 5 was inserted in the same position where 3 existed a while ago(before deletion). * So, it makes sense that, if we print address of each of these numbers, then address of 3 should be equal to address of 5 Practical Demonstration of LIFO: Let's write a program that demonstrates, that: a function on returning some value is deleted from stack and a new function called after it will occupy its position. Note: Please Visit pythontutor.com/c.html to visualize the STACK formed during execution of program. #include <stdio.h> int calculate_fib(int num){ // printing address of num. printf(\"Address: %u || Number: %d\\n\", &num, num); // check for 1 and 0 if(num <= 1) return 1; // else calculate the fib return calculate_fib(num - 1) + calculate_fib(num-2); } int main(int argc, char const *argv[]) { // calculating Fibonacci of 3 int result = calculate_fib(3); printf(\"Fib 4: %d\\n\", result); return 0; } The output of the above program is: Address: 1528622092 || Number: 3 Address: 1528622044 || Number: 2 Address: 1528621996 || Number: 1 Address: 1528621996 || Number: 0 Address: 1528622044 || Number: 1 Fib 3: 3 You could have noticed that: * Line 3 and 4 have same address. * Line 2 and 5 have same address. To understand the above issue, draw the STACK with following rule: * Insert the item from top and delete from top. You will notice that result of fib(1) was deleted and then fib(0) was loaded in same memory address, so, the address were same. Implementation of STACK: STACK can be implemented using 2 ways, i.e, * STATIC IMPLEMENTATION - ARRAY IMPLEMENTATION * DYNAMIC IMPLEMENTATION - LINKED LIST IMPLEMENTATION STATIC Implementation: Whenever actions of STACK are simulated using arrays, it is called static implementation. To implement the stack as array: * Create an array variable and restrict its insertion and deletion from one end. * To restrict the insertion and deletion, we need to create 2 functions, insert() and delete() and allow them to insert and delete item in our array. Algorithm for static implementation Variables Explanation: 1. Here, int *stack is a pointer variable which holds the address of stack array initialized with null values. 2. length is the integer variable holds max no of items that can be inserted in stack array. 3. item is the int variable that holds the data item to be inserted. Insert Function int insert(int *stack, int length, int item){ 1. Process for loop from i=0 to i<length; 2. If stack[i] != NULL then continue 3. Else: set stack[i] = item; return item; [End of step 2 loop] 4. print \"stack is full\" 5. return -1; } Delete Function void delete(int *stack, int length){ 1. process for loop from i=length-1 to i>0 2. if stack[i] is not NULL: set stack[i] = NULL break; } Traverse Function void traverse(int *stack, int length){ 1. process for loop from i=0 to i<length 2. If stack[i] == NULL then continue 3. Else print i and queue[i] } Main Function int main(){ 1. create an stack array with all elements initialized to null int stack[100] = {NULL} 2. Calculate length of stack using formula: int length = sizeof(stack) / sizeof(stack[0]) 3. Insert elements in array insert(&stack, length, 10); insert(&stack, length, 20); insert(&stack, length, 30); 4. Traverse the array traverse(&stack, length); 5. Delete the element from array delete(&stack, length); 6. Traverse the array traverse(&stack, length) return 0; } Algorithm written in C #include <stdio.h> // ++++++++++++++++++++++++++ // Insert Function // ++++++++++++++++++++++++++ int insert(int *stack, int length, int item){ for(int i=0; i<length; ++i){ if(stack[i] != NULL) continue; // if ith index of stack is not null stack[i] = item; return item; } // if stack is full return -1; } // ++++++++++++++++++++++++++ // Delete Function // ++++++++++++++++++++++++++ void delete(int *stack, int length){ for(int i=length -1; i>0; --i){ if(stack[i] != NULL){ stack[i] = NULL; break; } } } // ++++++++++++++++++++++++++ // Traverse Function // ++++++++++++++++++++++++++ void traverse(int *stack, int length){ for(int i=0; i<length; ++i){ if(stack[i] == NULL) continue; // means ith index of stack contains some item. printf(\"Index: %d holds Item: %d\\n\", i, stack[i]); } // just to seperate content printf(\"================================\\n\"); printf(\"================================\\n\"); printf(\"\\t Traversal Successful\\n\"); printf(\"================================\\n\"); printf(\"================================\\n\"); } // ++++++++++++++++++++++++++ // Main Function // ++++++++++++++++++++++++++ int main(int argc, char const *argv[]) { // create stack and calculate its length int stack[100] = {NULL}; int length = sizeof(stack)/ sizeof(stack[0]); // insert element in stack insert(&stack, length, 10); insert(&stack, length, 20); insert(&stack, length, 30); // traverse elements in stack traverse(&stack, length); // delete elements from stack delete(&stack, length); delete(&stack, length); // traverse elements from stack traverse(&stack, length); return 0; }","title":"02. OS Stack"},{"location":"dsa/02-os-stack/#intro-to-stack","text":"Stack is a part of memory, created during the application runtime. It holds all the local variables and instances of functions in it. Let's say we have a program, consisting of 3 functions as follows: #include <stdio.h> // Function pi float pi(){ return 22/7; } // function calculate float pi_times(int num){ return pi() * num; } // main function int main(int argc, char const *argv[]) { // calculating the pi squared. int squared = pi_times(2); printf(\"PI Squared: %.14f\\n\", squared); return 0; }","title":"Intro to Stack:"},{"location":"dsa/02-os-stack/#note","text":"To visualize the above code working please visit pythontutor.com/c.html Paste the code and press visualize execution button. After pressing visualize button you will see Forward button. Click forward button and see the stack in action. Now, the Operating System needs to solve the functions. In order to solve the above program, The Operating System: * Allocates RAM for program * Loads the program in RAM * Solves each function one by one inside STACK * Free the memory allocated for each function, whenever the function returns some value. * Finally, free the memory reserved for whole program. Let's understand different parts of RAM, allocated by OS. We have already discussed in introduction section, that each program on loading in RAM , loads in 4 different sections. They are: Text Environment Variables Heap Stack Now, in this lesson, we will study one of the memory section from above 4 sections, that is STACK","title":"Note:"},{"location":"dsa/02-os-stack/#working-of-stack","text":"Stack is a data structure, that holds some data. The data could be of any type, such as int, float, char, pointer, structure, union etc. The STACK follows some conditions, which differentiates it from other data structures , that is: * Item in STACK can be inserted and deleted from TOP of STACK. The above terminology \"insertion and deletion from top\" has given STACK a short form LIFO described as, LAST IN FIRST OUT LIFO simply means, the data item inserted at last will be evaluated first.","title":"Working of Stack"},{"location":"dsa/02-os-stack/#example-to-demonstrate-the-example","text":"Consider, the STACK as bunch of boxes, each able to store a number. Step 1: Each Box represent a single part of STACK memory Memory | Index [] 0 [] 1 [] 2 [] 3 Adding 1, 2, 3 in the STACK Memory | Index [1] 0 [2] 1 [3] 2 [] 3 Deleting an item from STACK Memory | Index [1] 0 [2] 1 [] 2 [] 3 Adding 5 in the STACK Memory | Index [1] 0 [2] 1 [5] 2 [] 3 Note: You will notice that, * 3 was deleted from stack and 5 was inserted in the same position where 3 existed a while ago(before deletion). * So, it makes sense that, if we print address of each of these numbers, then address of 3 should be equal to address of 5","title":"Example to Demonstrate the example:"},{"location":"dsa/02-os-stack/#practical-demonstration-of-lifo","text":"Let's write a program that demonstrates, that: a function on returning some value is deleted from stack and a new function called after it will occupy its position.","title":"Practical Demonstration of LIFO:"},{"location":"dsa/02-os-stack/#note_1","text":"Please Visit pythontutor.com/c.html to visualize the STACK formed during execution of program. #include <stdio.h> int calculate_fib(int num){ // printing address of num. printf(\"Address: %u || Number: %d\\n\", &num, num); // check for 1 and 0 if(num <= 1) return 1; // else calculate the fib return calculate_fib(num - 1) + calculate_fib(num-2); } int main(int argc, char const *argv[]) { // calculating Fibonacci of 3 int result = calculate_fib(3); printf(\"Fib 4: %d\\n\", result); return 0; } The output of the above program is: Address: 1528622092 || Number: 3 Address: 1528622044 || Number: 2 Address: 1528621996 || Number: 1 Address: 1528621996 || Number: 0 Address: 1528622044 || Number: 1 Fib 3: 3 You could have noticed that: * Line 3 and 4 have same address. * Line 2 and 5 have same address. To understand the above issue, draw the STACK with following rule: * Insert the item from top and delete from top. You will notice that result of fib(1) was deleted and then fib(0) was loaded in same memory address, so, the address were same.","title":"Note:"},{"location":"dsa/02-os-stack/#implementation-of-stack","text":"STACK can be implemented using 2 ways, i.e, * STATIC IMPLEMENTATION - ARRAY IMPLEMENTATION * DYNAMIC IMPLEMENTATION - LINKED LIST IMPLEMENTATION","title":"Implementation of STACK:"},{"location":"dsa/02-os-stack/#static-implementation","text":"Whenever actions of STACK are simulated using arrays, it is called static implementation. To implement the stack as array: * Create an array variable and restrict its insertion and deletion from one end. * To restrict the insertion and deletion, we need to create 2 functions, insert() and delete() and allow them to insert and delete item in our array.","title":"STATIC Implementation:"},{"location":"dsa/02-os-stack/#algorithm-for-static-implementation","text":"Variables Explanation: 1. Here, int *stack is a pointer variable which holds the address of stack array initialized with null values. 2. length is the integer variable holds max no of items that can be inserted in stack array. 3. item is the int variable that holds the data item to be inserted. Insert Function int insert(int *stack, int length, int item){ 1. Process for loop from i=0 to i<length; 2. If stack[i] != NULL then continue 3. Else: set stack[i] = item; return item; [End of step 2 loop] 4. print \"stack is full\" 5. return -1; } Delete Function void delete(int *stack, int length){ 1. process for loop from i=length-1 to i>0 2. if stack[i] is not NULL: set stack[i] = NULL break; } Traverse Function void traverse(int *stack, int length){ 1. process for loop from i=0 to i<length 2. If stack[i] == NULL then continue 3. Else print i and queue[i] } Main Function int main(){ 1. create an stack array with all elements initialized to null int stack[100] = {NULL} 2. Calculate length of stack using formula: int length = sizeof(stack) / sizeof(stack[0]) 3. Insert elements in array insert(&stack, length, 10); insert(&stack, length, 20); insert(&stack, length, 30); 4. Traverse the array traverse(&stack, length); 5. Delete the element from array delete(&stack, length); 6. Traverse the array traverse(&stack, length) return 0; }","title":"Algorithm for static implementation"},{"location":"dsa/02-os-stack/#algorithm-written-in-c","text":"#include <stdio.h> // ++++++++++++++++++++++++++ // Insert Function // ++++++++++++++++++++++++++ int insert(int *stack, int length, int item){ for(int i=0; i<length; ++i){ if(stack[i] != NULL) continue; // if ith index of stack is not null stack[i] = item; return item; } // if stack is full return -1; } // ++++++++++++++++++++++++++ // Delete Function // ++++++++++++++++++++++++++ void delete(int *stack, int length){ for(int i=length -1; i>0; --i){ if(stack[i] != NULL){ stack[i] = NULL; break; } } } // ++++++++++++++++++++++++++ // Traverse Function // ++++++++++++++++++++++++++ void traverse(int *stack, int length){ for(int i=0; i<length; ++i){ if(stack[i] == NULL) continue; // means ith index of stack contains some item. printf(\"Index: %d holds Item: %d\\n\", i, stack[i]); } // just to seperate content printf(\"================================\\n\"); printf(\"================================\\n\"); printf(\"\\t Traversal Successful\\n\"); printf(\"================================\\n\"); printf(\"================================\\n\"); } // ++++++++++++++++++++++++++ // Main Function // ++++++++++++++++++++++++++ int main(int argc, char const *argv[]) { // create stack and calculate its length int stack[100] = {NULL}; int length = sizeof(stack)/ sizeof(stack[0]); // insert element in stack insert(&stack, length, 10); insert(&stack, length, 20); insert(&stack, length, 30); // traverse elements in stack traverse(&stack, length); // delete elements from stack delete(&stack, length); delete(&stack, length); // traverse elements from stack traverse(&stack, length); return 0; }","title":"Algorithm written in C"},{"location":"python/01-intro/","text":"about page of about","title":"01. Introduction"},{"location":"python/01-intro/#about-page-of-about","text":"","title":"about page of about"}]}